title,body,answers_body,post_id,score,tags
How to append elements at the end of ArrayList in Java?,"<p>I am wondering, how do I append an element to the end of an ArrayList in Java? Here is the code I have so far: </p>

<pre><code>public class Stack {

    private ArrayList&lt;String&gt; stringList = new ArrayList&lt;String&gt;();

    RandomStringGenerator rsg = new RandomStringGenerator();

    private void push(){
        String random = rsg.randomStringGenerator();
        ArrayList.add(random);
    }

}
</code></pre>

<p>""randomStringGenerator"" is a method which generates a random String. </p>

<p>I basically want to always append the random string at the end of the ArrayList, much like a stack (Hence the name ""push"").</p>

<p>Thank you so much for your time! </p>","<p>Here is the syntax, along with some other methods you might find useful:</p>

<pre><code>    //add to the end of the list
    stringList.add(random);

    //add to the beginning of the list
    stringList.add(0,  random);

    //replace the element at index 4 with random
    stringList.set(4, random);

    //remove the element at index 5
    stringList.remove(5);

    //remove all elements from the list
    stringList.clear();
</code></pre>",22610526,41,java|arraylist|append
How to append elements at the end of ArrayList in Java?,"<p>I am wondering, how do I append an element to the end of an ArrayList in Java? Here is the code I have so far: </p>

<pre><code>public class Stack {

    private ArrayList&lt;String&gt; stringList = new ArrayList&lt;String&gt;();

    RandomStringGenerator rsg = new RandomStringGenerator();

    private void push(){
        String random = rsg.randomStringGenerator();
        ArrayList.add(random);
    }

}
</code></pre>

<p>""randomStringGenerator"" is a method which generates a random String. </p>

<p>I basically want to always append the random string at the end of the ArrayList, much like a stack (Hence the name ""push"").</p>

<p>Thank you so much for your time! </p>","<p>I know this is an old question, but I wanted to make an answer of my own. here is another way to do this if you ""really"" want to add to the end of the list instead of using <code>list.add(str)</code> you can do it this way, but I don't recommend.</p>

<pre><code> String[] items = new String[]{""Hello"", ""World""};
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list, items);
        int endOfList = list.size();
        list.add(endOfList, ""This goes end of list"");
        System.out.println(Collections.singletonList(list));
</code></pre>

<p><em>this is the 'Compact' way of adding the item to the end of list.
here is a safer way to do this, with null checking and more.</em></p>

<pre><code>String[] items = new String[]{""Hello"", ""World""};
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        Collections.addAll(list, items);
        addEndOfList(list, ""Safer way"");
        System.out.println(Collections.singletonList(list));

 private static void addEndOfList(List&lt;String&gt; list, String item){
            try{
                list.add(getEndOfList(list), item);
            } catch (IndexOutOfBoundsException e){
                System.out.println(e.toString());
            }
        }

   private static int getEndOfList(List&lt;String&gt; list){
        if(list != null) {
            return list.size();
        }
        return -1;
    }
</code></pre>

<p>Heres another way to add items to the end of list, happy coding :)</p>",22610526,1,java|arraylist|append
How to append elements at the end of ArrayList in Java?,"<p>I am wondering, how do I append an element to the end of an ArrayList in Java? Here is the code I have so far: </p>

<pre><code>public class Stack {

    private ArrayList&lt;String&gt; stringList = new ArrayList&lt;String&gt;();

    RandomStringGenerator rsg = new RandomStringGenerator();

    private void push(){
        String random = rsg.randomStringGenerator();
        ArrayList.add(random);
    }

}
</code></pre>

<p>""randomStringGenerator"" is a method which generates a random String. </p>

<p>I basically want to always append the random string at the end of the ArrayList, much like a stack (Hence the name ""push"").</p>

<p>Thank you so much for your time! </p>","<p>I ran into a similar problem and just passed the end of the array to the <code>ArrayList.add()</code> index param like so:</p>

<pre><code>public class Stack {

    private ArrayList&lt;String&gt; stringList = new ArrayList&lt;String&gt;();

    RandomStringGenerator rsg = new RandomStringGenerator();

    private void push(){
        String random = rsg.randomStringGenerator();
        stringList.add(stringList.size(), random);
    }

}
</code></pre>",22610526,0,java|arraylist|append
How to append elements at the end of ArrayList in Java?,"<p>I am wondering, how do I append an element to the end of an ArrayList in Java? Here is the code I have so far: </p>

<pre><code>public class Stack {

    private ArrayList&lt;String&gt; stringList = new ArrayList&lt;String&gt;();

    RandomStringGenerator rsg = new RandomStringGenerator();

    private void push(){
        String random = rsg.randomStringGenerator();
        ArrayList.add(random);
    }

}
</code></pre>

<p>""randomStringGenerator"" is a method which generates a random String. </p>

<p>I basically want to always append the random string at the end of the ArrayList, much like a stack (Hence the name ""push"").</p>

<p>Thank you so much for your time! </p>","<pre><code>import java.util.*;


public class matrixcecil {
    public static void main(String args[]){
        List&lt;Integer&gt; k1=new ArrayList&lt;Integer&gt;(10);
        k1.add(23);
        k1.add(10);
        k1.add(20);
        k1.add(24);
        int i=0;
        while(k1.size()&lt;10){
            if(i==(k1.get(k1.size()-1))){

            }
             i=k1.get(k1.size()-1);
             k1.add(30);
             i++;
             break;
        }
        System.out.println(k1);
    }

}
</code></pre>

<p>I think this example will help you for better solution.</p>",22610526,0,java|arraylist|append
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>You should use the overloaded sort(peps, new People()) method</p>

<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Test 
{
    public static void main(String[] args) 
    {
        List&lt;People&gt; peps = new ArrayList&lt;&gt;();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps, new People().new ComparatorId());

        for (int i = 0; i &lt; peps.size(); i++)
        {
            System.out.println(peps.get(i));
        }
    }
}

class People
{
       private int id;
       private String info;
       private double price;

       public People()
       {

       }

       public People(int newid, String newinfo, double newprice) {
           setid(newid);
           setinfo(newinfo);
           setprice(newprice);
       }

       public int getid() {
           return id;
       }

       public void setid(int id) {
           this.id = id;
       }

       public String getinfo() {
           return info;
       }

       public void setinfo(String info) {
           this.info = info;
       }

       public double getprice() {
           return price;
       }

       public void setprice(double price) {
           this.price = price;
       }

       class ComparatorId implements Comparator&lt;People&gt;
       {

        @Override
        public int compare(People obj1, People obj2) {
               Integer p1 = obj1.getid();
               Integer p2 = obj2.getid();

               if (p1 &gt; p2) {
                   return 1;
               } else if (p1 &lt; p2){
                   return -1;
               } else {
                   return 0;
               }
            }
       }
    }
</code></pre>",2839137,0,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>Here's a super short template to do the sorting right away :</p>

<pre><code>Collections.sort(people,new Comparator&lt;Person&gt;(){
   @Override
   public int compare(final Person lhs,Person rhs) {
     //TODO return 1 if rhs should be before lhs 
     //     return -1 if lhs should be before rhs
     //     return 0 otherwise (meaning the order stays the same)
     }
 });
</code></pre>

<p>if it's hard to remember, try to just remember that it's similar (in terms of the sign of the number) to:</p>

<pre><code> lhs-rhs 
</code></pre>

<p>That's in case you want to sort in ascending order : from smallest number to largest number.</p>",2839137,158,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>For the sake of completeness.</p>

<p>Using Java8</p>

<pre class=""lang-java prettyprint-override""><code>people.sort(Comparator.comparingInt(People::getId));
</code></pre>

<p>if you want in <code>descending order</code></p>

<pre class=""lang-java prettyprint-override""><code>people.sort(Comparator.comparingInt(People::getId).reversed());
</code></pre>",2839137,1,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>For the sake of completeness, here's a simple one-liner <code>compare</code> method:</p>

<pre><code>Collections.sort(people, new Comparator&lt;Person&gt;() {
    @Override
    public int compare(Person lhs, Person rhs) {  
        return Integer.signum(lhs.getId() - rhs.getId());  
    }
});
</code></pre>",2839137,17,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>Here is my answer for a simple comparator tool</p>

<pre><code>public class Comparator {
public boolean isComparatorRunning  = false;
public void compareTableColumns(List&lt;String&gt; tableNames) {
    if(!isComparatorRunning) {
        isComparatorRunning = true;
        try {
            for (String schTableName : tableNames) {
                Map&lt;String, String&gt; schemaTableMap = ComparatorUtil.getSchemaTableMap(schTableName); 
                Map&lt;String, ColumnInfo&gt; primaryColMap = ComparatorUtil.getColumnMetadataMap(DbConnectionRepository.getConnectionOne(), schemaTableMap);
                Map&lt;String, ColumnInfo&gt; secondaryColMap = ComparatorUtil.getColumnMetadataMap(DbConnectionRepository.getConnectionTwo(), schemaTableMap);
                ComparatorUtil.publishColumnInfoOutput(""Comparing table : ""+ schemaTableMap.get(CompConstants.TABLE_NAME));
                compareColumns(primaryColMap, secondaryColMap);
            }
        } catch (Exception e) {
            ComparatorUtil.publishColumnInfoOutput(""ERROR""+e.getMessage());
        }
        isComparatorRunning = false;
    }
}

public void compareColumns(Map&lt;String, ColumnInfo&gt; primaryColMap, Map&lt;String, ColumnInfo&gt; secondaryColMap) {
    try {
        boolean isEqual = true;
        for(Map.Entry&lt;String, ColumnInfo&gt; entry : primaryColMap.entrySet()) {
            String columnName = entry.getKey();
            ColumnInfo primaryColInfo = entry.getValue();
            ColumnInfo secondaryColInfo = secondaryColMap.remove(columnName);
            if(secondaryColInfo == null) {
                // column is not present in Secondary Environment
                ComparatorUtil.publishColumnInfoOutput(""ALTER"", primaryColInfo);
                isEqual = false;
                continue;
            }
            if(!primaryColInfo.equals(secondaryColInfo)) {
                isEqual = false;
                // Column not equal in secondary env
                ComparatorUtil.publishColumnInfoOutput(""MODIFY"", primaryColInfo);
            }
        }
        if(!secondaryColMap.isEmpty()) {
            isEqual = false;
            for(Map.Entry&lt;String, ColumnInfo&gt; entry : secondaryColMap.entrySet()) {
                // column is not present in Primary Environment
                ComparatorUtil.publishColumnInfoOutput(""DROP"", entry.getValue());
            }
        }

        if(isEqual) {
            ComparatorUtil.publishColumnInfoOutput(""--Exact Match"");
        }
    } catch (Exception e) {
        ComparatorUtil.publishColumnInfoOutput(""ERROR""+e.getMessage());
    }
}

public void compareTableColumnsValues(String primaryTableName, String primaryColumnNames, String primaryCondition, String primaryKeyColumn, 
        String secTableName, String secColumnNames, String secCondition, String secKeyColumn) {
    if(!isComparatorRunning) {
        isComparatorRunning = true;
        Connection conn1 = DbConnectionRepository.getConnectionOne();
        Connection conn2 = DbConnectionRepository.getConnectionTwo();

        String query1 = buildQuery(primaryTableName, primaryColumnNames, primaryCondition, primaryKeyColumn);
        String query2 = buildQuery(secTableName, secColumnNames, secCondition, secKeyColumn);
        try {
            Map&lt;String,Map&lt;String, Object&gt;&gt; query1Data = executeAndRefactorData(conn1, query1, primaryKeyColumn);
            Map&lt;String,Map&lt;String, Object&gt;&gt; query2Data = executeAndRefactorData(conn2, query2, secKeyColumn);

            for(Map.Entry&lt;String,Map&lt;String, Object&gt;&gt; entry : query1Data.entrySet()) {
                String key = entry.getKey();
                Map&lt;String, Object&gt; value = entry.getValue();
                Map&lt;String, Object&gt; secondaryValue = query2Data.remove(key);
                if(secondaryValue == null) {
                    ComparatorUtil.publishColumnValuesInfoOutput(""NO SUCH VALUE AVAILABLE IN SECONDARY DB ""+ value.toString());
                    continue;
                }
                compareMap(value, secondaryValue, key);
            }

            if(!query2Data.isEmpty()) {
                ComparatorUtil.publishColumnValuesInfoOutput(""Extra Values in Secondary table ""+ ((Map)query2Data.values()).values().toString());
            }
        } catch (Exception e) {
            ComparatorUtil.publishColumnValuesInfoOutput(""ERROR""+e.getMessage());
        }
        isComparatorRunning = false;
    }
}

private void compareMap(Map&lt;String, Object&gt; primaryValues, Map&lt;String, Object&gt; secondaryValues, String columnIdentification) {
    for(Map.Entry&lt;String, Object&gt; entry : primaryValues.entrySet()) {
        String key = entry.getKey();
        Object value = entry.getValue();
        Object secValue = secondaryValues.get(key);
        if(value!=null &amp;&amp; secValue!=null &amp;&amp; !String.valueOf(value).equalsIgnoreCase(String.valueOf(secValue))) {
            ComparatorUtil.publishColumnValuesInfoOutput(columnIdentification+"" : Secondary Table does not match value (""+ value +"") for column (""+ key+"")"");
        }
        if(value==null &amp;&amp; secValue!=null) {
            ComparatorUtil.publishColumnValuesInfoOutput(columnIdentification+"" : Values not available in primary table for column ""+ key);
        }
        if(value!=null &amp;&amp; secValue==null) {
            ComparatorUtil.publishColumnValuesInfoOutput(columnIdentification+"" : Values not available in Secondary table for column ""+ key);
        }
    }
}

private String buildQuery(String tableName, String column, String condition, String keyCol) {
    if(!""*"".equalsIgnoreCase(column)) {
        String[] keyColArr = keyCol.split("","");
        for(String key: keyColArr) {
            if(!column.contains(key.trim())) {
                column+="",""+key.trim();
            }
        }
    }
    StringBuilder queryBuilder = new StringBuilder();
    queryBuilder.append(""select ""+column+"" from ""+ tableName);
    if(!ComparatorUtil.isNullorEmpty(condition)) {
        queryBuilder.append("" where 1=1 and ""+condition);
    }
    return queryBuilder.toString();
}

private Map&lt;String,Map&lt;String, Object&gt;&gt; executeAndRefactorData(Connection connection, String query, String keyColumn) {
    Map&lt;String,Map&lt;String, Object&gt;&gt; result = new HashMap&lt;String, Map&lt;String,Object&gt;&gt;();
    try {
        PreparedStatement preparedStatement = connection.prepareStatement(query);
        ResultSet resultSet = preparedStatement.executeQuery();
        resultSet.setFetchSize(1000);
        if (resultSet != null &amp;&amp; !resultSet.isClosed()) {
            while (resultSet.next()) {
                Map&lt;String, Object&gt; columnValueDetails = new HashMap&lt;String, Object&gt;();
                int columnCount = resultSet.getMetaData().getColumnCount();
                for (int i=1; i&lt;=columnCount; i++) {
                    String columnName = String.valueOf(resultSet.getMetaData().getColumnName(i));
                    Object columnValue = resultSet.getObject(columnName);
                    columnValueDetails.put(columnName, columnValue);
                }
                String[] keys = keyColumn.split("","");
                String newKey = """";
                for(int j=0; j&lt;keys.length; j++) {
                    newKey += String.valueOf(columnValueDetails.get(keys[j]));
                }
                result.put(newKey , columnValueDetails);
            }
        }

    } catch (SQLException e) {
        ComparatorUtil.publishColumnValuesInfoOutput(""ERROR""+e.getMessage());
    }
    return result;
}
</code></pre>

<p>}</p>

<p>Utility Tool for the same</p>

<pre><code>public class ComparatorUtil {

public static Map&lt;String, String&gt; getSchemaTableMap(String tableNameWithSchema) {
    if(isNullorEmpty(tableNameWithSchema)) {
        return null;
    }
    Map&lt;String, String&gt; result = new LinkedHashMap&lt;&gt;();
    int index = tableNameWithSchema.indexOf(""."");
    String schemaName = tableNameWithSchema.substring(0, index);
    String tableName = tableNameWithSchema.substring(index+1);
    result.put(CompConstants.SCHEMA_NAME, schemaName);
    result.put(CompConstants.TABLE_NAME, tableName);
    return result;
}

public static Map&lt;String, ColumnInfo&gt; getColumnMetadataMap(Connection conn, Map&lt;String, String&gt; schemaTableMap) {
    try {
        String schemaName = schemaTableMap.get(CompConstants.SCHEMA_NAME);
        String tableName = schemaTableMap.get(CompConstants.TABLE_NAME);
        ResultSet resultSetConnOne = conn.getMetaData().getColumns(null, schemaName, tableName, null);
        Map&lt;String, ColumnInfo&gt; resultSetTwoColInfo = getColumnInfo(schemaName, tableName, resultSetConnOne);
        return resultSetTwoColInfo;
    } catch (SQLException e) {
        e.printStackTrace();
    }
    return null;
}

/* Number Type mapping
 * 12-----VARCHAR
 * 3-----DECIMAL
 * 93-----TIMESTAMP
 * 1111-----OTHER
*/
public static Map&lt;String, ColumnInfo&gt; getColumnInfo(String schemaName, String tableName, ResultSet columns) {
    try {
        Map&lt;String, ColumnInfo&gt; tableColumnInfo = new LinkedHashMap&lt;String, ColumnInfo&gt;();
        while (columns.next()) {
            ColumnInfo columnInfo = new ColumnInfo();
            columnInfo.setSchemaName(schemaName);
            columnInfo.setTableName(tableName);
            columnInfo.setColumnName(columns.getString(""COLUMN_NAME""));
            columnInfo.setDatatype(columns.getString(""DATA_TYPE""));
            columnInfo.setColumnsize(columns.getString(""COLUMN_SIZE""));
            columnInfo.setDecimaldigits(columns.getString(""DECIMAL_DIGITS""));
            columnInfo.setIsNullable(columns.getString(""IS_NULLABLE""));
            tableColumnInfo.put(columnInfo.getColumnName(), columnInfo);
        }
        return tableColumnInfo;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}

public static boolean isNullOrEmpty(Object obj) {
    if (obj == null)
        return true;
    if (String.valueOf(obj).equalsIgnoreCase(""NULL"")) 
        return true;
    if (obj.toString().trim().length() == 0)
        return true;
    return false;
}



public static boolean isNullorEmpty(String str) {
    if(str == null)
        return true;
    if(str.trim().length() == 0) 
        return true;
    return false;
}

public static void publishColumnInfoOutput(String type, ColumnInfo columnInfo) {
    String str = ""ALTER TABLE ""+columnInfo.getSchemaName()+"".""+columnInfo.getTableName();
    switch(type.toUpperCase()) {
        case ""ALTER"":
            if(""NUMBER"".equalsIgnoreCase(columnInfo.getDatatype()) || ""DATE"".equalsIgnoreCase(columnInfo.getDatatype())) {
                str += "" ADD (""+columnInfo.getColumnName()+"" ""+ columnInfo.getDatatype()+"");"";
            } else {
                str += "" ADD (""+columnInfo.getColumnName()+"" ""+ columnInfo.getDatatype() +""(""+columnInfo.getColumnsize()+""));"";
            }
            break;
        case ""DROP"":
            str += "" DROP (""+columnInfo.getColumnName()+"");"";
            break;
        case ""MODIFY"":
            if(""NUMBER"".equalsIgnoreCase(columnInfo.getDatatype()) || ""DATE"".equalsIgnoreCase(columnInfo.getDatatype())) {
                str += "" MODIFY (""+columnInfo.getColumnName()+"" ""+ columnInfo.getDatatype()+"");"";
            } else {
                str += "" MODIFY (""+columnInfo.getColumnName()+"" ""+ columnInfo.getDatatype() +""(""+columnInfo.getColumnsize()+""));"";
            }
            break;
    }
    publishColumnInfoOutput(str);
}

public static Map&lt;Integer, String&gt; allJdbcTypeName = null;

public static Map&lt;Integer, String&gt; getAllJdbcTypeNames() {
    Map&lt;Integer, String&gt; result = new HashMap&lt;Integer, String&gt;();
    if(allJdbcTypeName != null)
        return allJdbcTypeName;
    try {
        for (Field field : java.sql.Types.class.getFields()) {
            result.put((Integer) field.get(null), field.getName());
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return allJdbcTypeName=result;
}

public static String getStringPlaces(String[] attribs) {
    String params = """";
    for(int i=0; i&lt;attribs.length; i++) { params += ""?,""; }
    return params.substring(0, params.length()-1);
}
</code></pre>

<p>}</p>

<p>Column Info Class </p>

<pre><code>public class ColumnInfo {
private String schemaName;
private String tableName;
private String columnName;
private String datatype;
private String columnsize;
private String decimaldigits;
private String isNullable;
</code></pre>",2839137,0,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>Java 8 added a new way of making Comparators that reduces the amount of code you have to write, <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#comparing-java.util.function.Function-"" rel=""noreferrer"">Comparator.comparing</a>. Also check out <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#reversed--"" rel=""noreferrer"">Comparator.reversed</a> </p>

<p>Here's a sample</p>

<pre><code>import org.junit.Test;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.junit.Assert.assertTrue;

public class ComparatorTest {

    @Test
    public void test() {
        List&lt;Person&gt; peopleList = new ArrayList&lt;&gt;();
        peopleList.add(new Person(""A"", 1000));
        peopleList.add(new Person(""B"", 1));
        peopleList.add(new Person(""C"", 50));
        peopleList.add(new Person(""Z"", 500));
        //sort by name, ascending
        peopleList.sort(Comparator.comparing(Person::getName));
        assertTrue(peopleList.get(0).getName().equals(""A""));
        assertTrue(peopleList.get(peopleList.size() - 1).getName().equals(""Z""));
        //sort by name, descending
        peopleList.sort(Comparator.comparing(Person::getName).reversed());
        assertTrue(peopleList.get(0).getName().equals(""Z""));
        assertTrue(peopleList.get(peopleList.size() - 1).getName().equals(""A""));
        //sort by age, ascending
        peopleList.sort(Comparator.comparing(Person::getAge));
        assertTrue(peopleList.get(0).getAge() == 1);
        assertTrue(peopleList.get(peopleList.size() - 1).getAge() == 1000);
        //sort by age, descending
        peopleList.sort(Comparator.comparing(Person::getAge).reversed());
        assertTrue(peopleList.get(0).getAge() == 1000);
        assertTrue(peopleList.get(peopleList.size() - 1).getAge() == 1);
    }

    class Person {

        String name;
        int age;

        Person(String n, int a) {
            name = n;
            age = a;
        }

        public String getName() {
            return name;
        }

        public int getAge() {
            return age;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void setAge(int age) {
            this.age = age;
        }
    }



}
</code></pre>",2839137,11,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>Here's an example of a Comparator that will work for any zero arg method that returns a Comparable.  Does something like this exist in a jdk or library?</p>

<pre><code>import java.lang.reflect.Method;
import java.util.Comparator;

public class NamedMethodComparator implements Comparator&lt;Object&gt; {

    //
    // instance variables
    //

    private String methodName;

    private boolean isAsc;

    //
    // constructor
    //

    public NamedMethodComparator(String methodName, boolean isAsc) {
        this.methodName = methodName;
        this.isAsc = isAsc;
    }

    /**
     * Method to compare two objects using the method named in the constructor.
     */
    @Override
    public int compare(Object obj1, Object obj2) {
        Comparable comp1 = getValue(obj1, methodName);
        Comparable comp2 = getValue(obj2, methodName);
        if (isAsc) {
            return comp1.compareTo(comp2);
        } else {
            return comp2.compareTo(comp1);
        }
    }

    //
    // implementation
    //

    private Comparable getValue(Object obj, String methodName) {
        Method method = getMethod(obj, methodName);
        Comparable comp = getValue(obj, method);
        return comp;
    }

    private Method getMethod(Object obj, String methodName) {
        try {
            Class[] signature = {};
            Method method = obj.getClass().getMethod(methodName, signature);
            return method;
        } catch (Exception exp) {
            throw new RuntimeException(exp);
        }
    }

    private Comparable getValue(Object obj, Method method) {
        Object[] args = {};
        try {
            Object rtn = method.invoke(obj, args);
            Comparable comp = (Comparable) rtn;
            return comp;
        } catch (Exception exp) {
            throw new RuntimeException(exp);
        }
    }

}
</code></pre>",2839137,2,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p><code>Two corrections:</code></p>

<p>First, you have to make an ArrayList of People objects:</p>

<p><code>ArrayList&lt;People&gt; preps= new ArrayList&lt;People&gt;();</code> </p>

<p>And then after adding the objects to the preps, use: </p>

<p><code>Collections.sort(preps,new CompareId());</code></p>

<p>Also add a CompareId class as: </p>

<pre><code>class CompareId implements Comparator{  
    public int compare(Object obj1,Object obj2){  
        People t1=(People)obj1;  
        People t2=(People)obj2;  

    if(t1.marks&gt;t2.marks)  
            return 1;   
    else  
            return -1;

    }  
}
</code></pre>",2839137,0,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>The solution can be optimized in following way:
Firstly, use a private inner class as the scope for the fields is to be the enclosing class TestPeople so as the implementation of class People won't get exposed to outer world. This can be understood in terms of creating an APIthat expects a sorted list of people
Secondly, using the Lamba expression(java 8) which reduces the code, hence development effort</p>

<p>Hence code would be as below:</p>

<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList&lt;People&gt; peps = new ArrayList&lt;&gt;();// Be specific, to avoid
                                                    // classCast Exception

        TestPeople test = new TestPeople();

        peps.add(test.new People(123, ""M"", 14.25));
        peps.add(test.new People(234, ""M"", 6.21));
        peps.add(test.new People(362, ""F"", 9.23));
        peps.add(test.new People(111, ""M"", 65.99));
        peps.add(test.new People(535, ""F"", 9.23));

        /*
         * Collections.sort(peps);
         * 
         * for (int i = 0; i &lt; peps.size(); i++){
         * System.out.println(peps.get(i)); }
         */

        // The above code can be replaced by followin:

        peps.sort((People p1, People p2) -&gt; p1.getid() - p2.getid());

        peps.forEach((p) -&gt; System.out.println("" "" + p.toString()));

    }

    private class People {
        private int id;

        @Override
        public String toString() {
            return ""People [id="" + id + "", info="" + info + "", price="" + price + ""]"";
        }

        private String info;
        private double price;

        public People(int newid, String newinfo, double newprice) {
            setid(newid);
            setinfo(newinfo);
            setprice(newprice);
        }

        public int getid() {
            return id;
        }

        public void setid(int id) {
            this.id = id;
        }

        public String getinfo() {
            return info;
        }

        public void setinfo(String info) {
            this.info = info;
        }

        public double getprice() {
            return price;
        }

        public void setprice(double price) {
            this.price = price;
        }
    }
}
</code></pre>",2839137,1,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>You want to implement Comparable, not Comparator. You need to implement the compareTo method. You're close though. Comparator is a ""3rd party"" comparison routine. Comparable is that this object can be compared with another.</p>

<pre><code>public int compareTo(Object obj1) {
  People that = (People)obj1;
  Integer p1 = this.getId();
  Integer p2 = that.getid();

  if (p1 &gt; p2 ){
   return 1;
  }
  else if (p1 &lt; p2){
   return -1;
  }
  else
   return 0;
 }
</code></pre>

<p>Note, you may want to check for nulls in here for getId..just in case.</p>",2839137,4,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>Use <code>People implements Comparable&lt;People&gt;</code> instead; this defines the natural ordering for <code>People</code>.</p>

<p>A <code>Comparator&lt;People&gt;</code> can also be defined in addition, but <code>People implements Comparator&lt;People&gt;</code> is not the right way of doing things.</p>

<p>The two overloads for <code>Collections.sort</code> are different:</p>

<ul>
<li><code>&lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>

<ul>
<li>Sorts <code>Comparable</code> objects using their natural ordering</li>
</ul></li>
<li><code>&lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>

<ul>
<li>Sorts whatever using a compatible <code>Comparator</code></li>
</ul></li>
</ul>

<p>You're confusing the two by trying to sort a <code>Comparator</code> (which is again why it doesn't make sense that <code>Person implements Comparator&lt;Person&gt;</code>). Again, to use <code>Collections.sort</code>, you need one of these to be true:</p>

<ul>
<li>The type must be <code>Comparable</code> (use the 1-arg <code>sort</code>)</li>
<li>A <code>Comparator</code> for the type must be provided (use the 2-args <code>sort</code>)</li>
</ul>

<h3>Related questions</h3>

<ul>
<li><a href=""https://stackoverflow.com/questions/2266827/when-to-use-comparable-vs-comparator"">When to use Comparable vs Comparator</a></li>
<li><a href=""https://stackoverflow.com/questions/1814095/sorting-an-arraylist-of-contacts"">Sorting an ArrayList of Contacts</a></li>
</ul>

<hr>

<p>Also, <strong>do not use raw types in new code</strong>. Raw types are unsafe, and it's provided only for compatibility.</p>

<p>That is, instead of this:</p>

<pre><code>ArrayList peps = new ArrayList(); // BAD!!! No generic safety!
</code></pre>

<p>you should've used the typesafe generic declaration like this:</p>

<pre><code>List&lt;People&gt; peps = new ArrayList&lt;People&gt;(); // GOOD!!!
</code></pre>

<p>You will then find that <strong>your code doesn't even compile!!</strong> That would be a good thing, because there IS something wrong with the code (<code>Person</code> does not <code>implements Comparable&lt;Person&gt;</code>), <strong>but because you used raw type, the compiler didn't check for this</strong>, and instead you get a <code>ClassCastException</code> at run-time!!!</p>

<p>This should convince you to always use typesafe generic types in new code. Always.</p>

<h3>See also</h3>

<ul>
<li><a href=""https://stackoverflow.com/questions/2770321/what-is-a-raw-type-and-why-shouldnt-we-use-it"">What is a raw type and why shouldn't we use it?</a></li>
</ul>",2839137,39,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<p>There are a couple of awkward things with your example class:</p>

<ul>
<li>it's called People while it has a <code>price</code> and <code>info</code> (more something for objects, not people);</li>
<li>when naming a class as a plural of something, it suggests it is an abstraction of more than one thing. </li>
</ul>

<p>Anyway, here's a demo of how to use a <code>Comparator&lt;T&gt;</code>:</p>

<pre><code>public class ComparatorDemo {

    public static void main(String[] args) {
        List&lt;Person&gt; people = Arrays.asList(
                new Person(""Joe"", 24),
                new Person(""Pete"", 18),
                new Person(""Chris"", 21)
        );
        Collections.sort(people, new LexicographicComparator());
        System.out.println(people);
        Collections.sort(people, new AgeComparator());
        System.out.println(people);
    }
}

class LexicographicComparator implements Comparator&lt;Person&gt; {
    @Override
    public int compare(Person a, Person b) {
        return a.name.compareToIgnoreCase(b.name);
    }
}

class AgeComparator implements Comparator&lt;Person&gt; {
    @Override
    public int compare(Person a, Person b) {
        return a.age &lt; b.age ? -1 : a.age == b.age ? 0 : 1;
    }
}

class Person {

    String name;
    int age;

    Person(String n, int a) {
        name = n;
        age = a;
    }

    @Override
    public String toString() {
        return String.format(""{name=%s, age=%d}"", name, age);
    }
}
</code></pre>

<h2>EDIT</h2>

<p>And an equivalent Java 8 demo would look like this:</p>

<pre><code>public class ComparatorDemo {

    public static void main(String[] args) {
        List&lt;Person&gt; people = Arrays.asList(
                new Person(""Joe"", 24),
                new Person(""Pete"", 18),
                new Person(""Chris"", 21)
        );
        Collections.sort(people, (a, b) -&gt; a.name.compareToIgnoreCase(b.name));
        System.out.println(people);
        Collections.sort(people, (a, b) -&gt; a.age &lt; b.age ? -1 : a.age == b.age ? 0 : 1);
        System.out.println(people);
    }
}
</code></pre>",2839137,208,java|sorting|comparator
How to use Comparator in Java to sort,"<p>I learned how to use the comparable but I'm having difficulty with the Comparator. I am having a error in my code: </p>

<pre><code>Exception in thread ""main"" java.lang.ClassCastException: New.People cannot be cast to java.lang.Comparable
 at java.util.Arrays.mergeSort(Unknown Source)
 at java.util.Arrays.sort(Unknown Source)
 at java.util.Collections.sort(Unknown Source)
 at New.TestPeople.main(TestPeople.java:18)
</code></pre>

<p>Here is my code:</p>

<pre><code>import java.util.Comparator;

public class People implements Comparator {
   private int id;
   private String info;
   private double price;

   public People(int newid, String newinfo, double newprice) {
       setid(newid);
       setinfo(newinfo);
       setprice(newprice);
   }

   public int getid() {
       return id;
   }

   public void setid(int id) {
       this.id = id;
   }

   public String getinfo() {
       return info;
   }

   public void setinfo(String info) {
       this.info = info;
   }

   public double getprice() {
       return price;
   }

   public void setprice(double price) {
       this.price = price;
   }

   public int compare(Object obj1, Object obj2) {
       Integer p1 = ((People) obj1).getid();
       Integer p2 = ((People) obj2).getid();

       if (p1 &gt; p2) {
           return 1;
       } else if (p1 &lt; p2){
           return -1;
       } else {
           return 0;
       }
    }
}
</code></pre>

<pre class=""lang-java prettyprint-override""><code>import java.util.ArrayList;
import java.util.Collections;

public class TestPeople {
    public static void main(String[] args) {
        ArrayList peps = new ArrayList();

        peps.add(new People(123, ""M"", 14.25));
        peps.add(new People(234, ""M"", 6.21));
        peps.add(new People(362, ""F"", 9.23));
        peps.add(new People(111, ""M"", 65.99));
        peps.add(new People(535, ""F"", 9.23));

        Collections.sort(peps);

        for (int i = 0; i &lt; peps.size(); i++){
            System.out.println(peps.get(i));
        }
    }
}
</code></pre>

<p>I believe it has to do something with the casting in the compare method but I was playing around with it and still could not find the solution</p>","<pre><code>public static Comparator&lt;JobSet&gt; JobEndTimeComparator = new Comparator&lt;JobSet&gt;() {
            public int compare(JobSet j1, JobSet j2) {
                int cost1 = j1.cost;
                int cost2 = j2.cost;
                return cost1-cost2;
            }
        };
</code></pre>",2839137,1,java|sorting|comparator
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>I like the comparator class <code>SortIgnoreCase</code>, but would have used this</p>

<pre><code>public class SortIgnoreCase implements Comparator&lt;String&gt; {
    public int compare(String s1, String s2) {
        return s1.compareToIgnoreCase(s2);    // Cleaner :)
    }
}
</code></pre>",7469643,5,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<pre><code>Collections.sort(listToSort, String.CASE_INSENSITIVE_ORDER);
</code></pre>",7469643,157,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>I can't believe no one made a reference to the <a href=""https://docs.oracle.com/javase/tutorial/i18n/text/collationintro.html"" rel=""noreferrer"">Collator</a>. Almost all of these answers will only work for the English language.</p>

<p>You should almost always use a <a href=""https://docs.oracle.com/javase/7/docs/api/java/text/Collator.html"" rel=""noreferrer"">Collator for dictionary based sorting</a>.</p>

<p>For case insensitive collator searching for the English language you do the following:</p>

<pre><code>Collator usCollator = Collator.getInstance(Locale.US);
usCollator.setStrength(Collator.PRIMARY);
Collections.sort(listToSort, usCollator);
</code></pre>",7469643,13,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>You can directly call the default <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/List.html#sort-java.util.Comparator-"" rel=""nofollow noreferrer"">sort</a> method on the list like this:</p>

<pre><code>myList.sort(String.CASE_INSENSITIVE_ORDER); // reads as the problem statement and cleaner
</code></pre>

<p>or:</p>

<pre><code>myList.sort(String::compareToIgnoreCase);  // reads as the problem statement and cleaner
</code></pre>",7469643,1,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p><code>Collections.sort()</code> lets you pass a custom comparator for ordering. For case insensitive ordering <code>String</code> class provides a static final comparator called <code>CASE_INSENSITIVE_ORDER</code>.</p>

<p>So in your case all that's needed is:</p>

<pre><code>Collections.sort(caps, String.CASE_INSENSITIVE_ORDER);
</code></pre>",7469643,34,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p><strong>Example using Collections and ArrayList:</strong></p>

<p>Develop an intern static class like the example ""CompareStrings"".</p>

<p>Call the intern static class in the main method.</p>

<p>Easy to understand and works fine!</p>

<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class MainClass {
    public static void main(String[] args) {
        ArrayList&lt;String&gt; myArray = new ArrayList&lt;String&gt;();
        myArray.add(""zzz"");
        myArray.add(""xxx"");
        myArray.add(""Aaa"");
        myArray.add(""bb"");
        myArray.add(""BB"");
        Collections.sort(myArray, new MainClass.CompareStrings());
        for(String s : myArray) {
            System.out.println(s);
        }
    }

    public static class CompareStrings implements Comparator&lt;String&gt; {
        @Override
        public int compare(String s1, String s2) {
           return s1.compareToIgnoreCase(s2);
        }
    }
}
</code></pre>",7469643,0,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>Pass <code>java.text.Collator.getInstance()</code> to <code>Collections.sort</code> method ; it will sort Alphabetically while ignoring case sensitive.</p>

<pre><code>        ArrayList&lt;String&gt; myArray = new ArrayList&lt;String&gt;();
        myArray.add(""zzz"");
        myArray.add(""xxx"");
        myArray.add(""Aaa"");
        myArray.add(""bb"");
        myArray.add(""BB"");
        Collections.sort(myArray,Collator.getInstance());
</code></pre>",7469643,3,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>Since Java 8 you can sort using the Streams API:</p>

<pre><code>List&lt;String&gt; fruits = Arrays.asList(""apple"", ""Apricot"", ""banana"");

List&lt;String&gt; sortedFruit = fruits.stream()
      .sorted(String.CASE_INSENSITIVE_ORDER)
      .collect(Collectors.toList())
</code></pre>

<p>The difference with <code>Collections.sort</code> is that this will return a new list and will not modify the existing one.</p>",7469643,3,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>In your comparator factory class, do something like this:</p>

<pre><code> private static final Comparator&lt;String&gt; MYSTRING_COMPARATOR = new Comparator&lt;String&gt;() {
    @Override
    public int compare(String s1, String s2) {
      return s1.compareToIgnoreCase(s2);
    }
  };

  public static Comparator&lt;String&gt; getMyStringComparator() {
    return MYSTRING_COMPARATOR;
</code></pre>

<p>This uses the compare to method which is case insensitive (why write your own). This way you can use Collections sort like this:</p>

<pre><code>List&lt;String&gt; myArray = new ArrayList&lt;String&gt;();
//fill your array here    
Collections.sort(MyArray, MyComparators. getMyStringComparator());
</code></pre>",7469643,1,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>Array Sorting in Java 8 Way-> Easy peasy lemon squeezy</p>

<pre><code>String[] names = {""Alexis"", ""Tim"", ""Kyleen"", ""KRISTY""};

  Arrays.sort(names, String::compareToIgnoreCase);
</code></pre>

<p>I used method Reference <code>String::compareToIgnoreCase</code></p>",7469643,1,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>",<p>did you tried converting the first char of the string to lowercase on <code>if(fruits[i].charAt(0) == currChar)</code> and <code>char currChar = fruits[0].charAt(0)</code> statements?</p>,7469643,0,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>Here's a plain java example of the best way to do it:</p>

<pre><code>import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

public class Sorter {
    String fruits[] = new String[7];
    List&lt;String&gt; lst;

    Sorter() {
        lst = new ArrayList&lt;String&gt;();
        // initialise UNSORTED array
        fruits[0] = ""Melon""; fruits[1] = ""apricot""; fruits[2] = ""peach"";
        fruits[3] = ""mango""; fruits[4] = ""Apple"";   fruits[5] = ""pineapple"";
        fruits[6] = ""banana"";
    }

    public static void main(String[] args) {
        Sorter srt = new Sorter();
        srt.anyOldUnstaticMethod();

    }
    public void anyOldUnstaticMethod() {
        Collections.addAll(lst, fruits);
        System.out.println(""Initial List"");
        for (String s : lst)
            System.out.println(s);
        Collections.sort(lst);
        System.out.println(""\nSorted List"");
        for (String s : lst)
            System.out.println(s);
        Collections.sort(lst, new SortIgnoreCase());
        System.out.println(""\nSorted Ignoring Case List"");
        for (String s : lst)
            System.out.println(s);
    }

    public class SortIgnoreCase implements Comparator&lt;Object&gt; {
        public int compare(Object o1, Object o2) {
            String s1 = (String) o1;
            String s2 = (String) o2;
            return s1.toLowerCase().compareTo(s2.toLowerCase());
        }
    }
}
</code></pre>",7469643,32,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>It is <strong>very</strong> unclear what you are trying to do, but you can sort a list like this:</p>

<pre><code>List&lt;String&gt; fruits = new ArrayList&lt;String&gt;(7);

fruits.add(""Pineapple"");
fruits.add(""apple"");
fruits.add(""apricot"");
fruits.add(""Banana"");
fruits.add(""mango"");
fruits.add(""melon"");        
fruits.add(""peach"");

System.out.println(""Unsorted: "" + fruits);

Collections.sort(fruits, new Comparator&lt;String&gt;() {
    @Override
    public int compare(String o1, String o2) {              
        return o1.compareToIgnoreCase(o2);
    }
});

System.out.println(""Sorted: "" + fruits);
</code></pre>",7469643,43,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>Here is an example to sort an array : Case-insensitive</p>

<pre><code>import java.text.Collator;
import java.util.Arrays;

public class Main {
  public static void main(String args[]) {

    String[] myArray = new String[] { ""A"", ""B"", ""b"" };
    Arrays.sort(myArray, Collator.getInstance());

  System.out.println(Arrays.toString(myArray));

 }

}
</code></pre>

<p>/* Output:[A, b, B] */</p>",7469643,-1,java|android|collections
How to sort alphabetically while ignoring case sensitive?,"<p>I have this code, but works only for lower case letters.  I want this to sort the list while ignoring the upper case letters..</p>

<pre><code>package sortarray.com;

import java.util.ArrayList;
import java.util.List;

import android.app.Activity;
import android.os.Bundle;
import android.util.Log;
import android.widget.TextView;

public class SortArray extends Activity {
    ArrayList&lt;String[]&gt; matchedFruits = new ArrayList&lt;String[]&gt;();
    TextView selection;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);

        String fruits[] = new String[7];// Sorted array
        fruits[0] = ""apple"";
        fruits[1] = ""apricot"";
        fruits[2] = ""banana"";
        fruits[3] = ""mango"";
        fruits[4] = ""melon"";
        fruits[5] = ""pineapple"";
        fruits[6] = ""peach"";
        char currChar = fruits[0].charAt(0);// Get first char of first element

        boolean match = false;
        int len = fruits.length;
        List&lt;String&gt; tmp = new ArrayList&lt;String&gt;();

        for (int i = 1; i &lt; len; i++) {
            Log.d(""Comparing "", fruits[i].charAt(0) + "","" + currChar);
            if (fruits[i].charAt(0) == currChar) {
                if (match == false)// new match?
                {
                    match = true;// Reset search
                    tmp.clear();// clear existing items
                    tmp.add(fruits[i - 1]);
                    Log.d(""Started new list "", fruits[i - 1]);
                } else {
                    tmp.add(fruits[i - 1]);
                    Log.d(""Added to list "", fruits[i - 1]);
                }
            } else {
                match = false;
                tmp.add(fruits[i - 1]);
                matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add to
                                                                        // final
                                                                        // list
                Log.d(""Finished a list "", fruits[i - 1]);
                tmp.clear();// clear existing items

            }
            currChar = fruits[i].charAt(0);

        }
        tmp.add(fruits[len - 1]);
        matchedFruits.add(tmp.toArray(new String[tmp.size()]));// add left over
                                                                // items
        printList();
    }

    void printList()
    {
    //Print the list 
        TextView selection = (TextView) findViewById(R.id.tv);
        String mssg="""";
    for(int i=0;i&lt;matchedFruits.size();i++)
    {
            String tmp2[]= matchedFruits.get(i);

            for (int j = 0; j &lt; tmp2.length; j++) {
                //Log.d(""Final list"", ""Array #"" + i + ""["" + j + ""],"" + tmp2[j]);
                mssg += tmp2[j].toString();

            }
            //selection.setText(""\n"");
            selection.setText(mssg);

    }
    }
}
</code></pre>","<p>In your case you have a <code>List</code> of Strings and most of the already proposed solutions (I specially like @guyblank answer) are just fine but!!!, if you have a <code>List</code> of beans, which is my case, you can use <code>Comparable</code> interface in your bean like this:</p>

<pre><code>public class UserBean implements Comparable&lt;UserBean&gt; {

   private String name;
   private String surname;        
   private Integer phone;

   // GETTERS AND SETTERS

   public int compareTo(UserBean bean) {
       return name.compareToIgnoreCase(bean.name);
   }

}
</code></pre>

<p>Then you only need to create your <code>ArrayList&lt;UserBean&gt; userBeanArray = new ArrayList&lt;UserBean&gt;();</code>, fill it and sort it: <code>Collections.sort(userBeanArray);</code></p>

<p>And you have it done!</p>

<p>Hope to help to community ;-)</p>",7469643,0,java|android|collections
How to print elements from an array list,"<p>I've looked online for help so far and nothing is working for me. This is what I have right now, can you please tell me what is wrong with it?</p>

<p>import java.util.*;</p>

<pre><code>class employeeProgram{

    public static void main(String[] args){

            for (int count = 0; count &lt; 1; ){

                    Scanner input = new Scanner(System.in);

                    ArrayList&lt;String&gt; employeeNames = new ArrayList&lt;String&gt;();

                    String commnd;

                    print(""What would you like to do? (Add, Remove, List, Exit): "");

                    commnd = input.next();

                    if (""Add"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to add to the list: "");
                            employeeNames.add(input.next());


                    } else if (""Remove"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to remove from the list: "");

                            employeeNames.remove(input.next());

                    } else if (""List"".equals(commnd)){

                            for (int j = 0; j &lt; employeeNames.size(); j++){

                                    println(employeeNames.get(j));
                                    println(j);

                            }


                            //println(employeeNames);

                    } else if (""Exit"".equals(commnd)){

                            input.close();
                            break;

                    } else {

                            println(""Invalid command."");

                    }
            }
    }
    public static void println(Object x){

            System.out.println(x);

    }
    public static void print(Object x){

            System.out.print(x);

    }

}
</code></pre>

<p>The for loop isn't beginning, I know that much because the ""println(j)"" wasn't working either. When I tried the part that I've commented out, all I got from typing list was ""[]"" and nothing else. I'm a beginner, and this is my first program using ArrayLists, so thanks in advance to anyone who decides to help me out :)</p>","<p>You are creating a new ArrayList everytime you ask a question.  Create it outside of the initial loop.</p>

<pre><code>ArrayList&lt;String&gt; employeeNames = new ArrayList&lt;String&gt;();
</code></pre>",19253202,0,java|arrays|printing|element
How to print elements from an array list,"<p>I've looked online for help so far and nothing is working for me. This is what I have right now, can you please tell me what is wrong with it?</p>

<p>import java.util.*;</p>

<pre><code>class employeeProgram{

    public static void main(String[] args){

            for (int count = 0; count &lt; 1; ){

                    Scanner input = new Scanner(System.in);

                    ArrayList&lt;String&gt; employeeNames = new ArrayList&lt;String&gt;();

                    String commnd;

                    print(""What would you like to do? (Add, Remove, List, Exit): "");

                    commnd = input.next();

                    if (""Add"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to add to the list: "");
                            employeeNames.add(input.next());


                    } else if (""Remove"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to remove from the list: "");

                            employeeNames.remove(input.next());

                    } else if (""List"".equals(commnd)){

                            for (int j = 0; j &lt; employeeNames.size(); j++){

                                    println(employeeNames.get(j));
                                    println(j);

                            }


                            //println(employeeNames);

                    } else if (""Exit"".equals(commnd)){

                            input.close();
                            break;

                    } else {

                            println(""Invalid command."");

                    }
            }
    }
    public static void println(Object x){

            System.out.println(x);

    }
    public static void print(Object x){

            System.out.print(x);

    }

}
</code></pre>

<p>The for loop isn't beginning, I know that much because the ""println(j)"" wasn't working either. When I tried the part that I've commented out, all I got from typing list was ""[]"" and nothing else. I'm a beginner, and this is my first program using ArrayLists, so thanks in advance to anyone who decides to help me out :)</p>","<p>You need to define your arraylist outsode of your loop, otherwise every iteration creates a new arrayList and the previous changes made to the previous arraylist is garbage collected.</p>

<pre><code>import java.util.*;

class employeeProgram{

    public static void main(String[] args){

            ArrayList&lt;String&gt; employeeNames = new ArrayList&lt;String&gt;();

            for (int count = 0; count &lt; 1; ){

                    Scanner input = new Scanner(System.in);



                    String commnd;

                    print(""What would you like to do? (Add, Remove, List, Exit): "");

                    commnd = input.next();

                    if (""Add"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to add to the list: "");
                            employeeNames.add(input.next());


                    } else if (""Remove"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to remove from the list: "");

                            employeeNames.remove(input.next());

                    } else if (""List"".equals(commnd)){

                            for (int j = 0; j &lt; employeeNames.size(); j++){

                                    println(employeeNames.get(j));
                                    println(j);

                            }


                            //println(employeeNames);

                    } else if (""Exit"".equals(commnd)){

                            input.close();
                            break;

                    } else {

                            println(""Invalid command."");

                    }
            }
    }
    public static void println(Object x){

            System.out.println(x);

    }
    public static void print(Object x){

            System.out.print(x);

    }

}
</code></pre>

<p>Also, there are a few basic changes I would make to this program, first of all - a for loop should be used where you know how many iterations you will do. In your case, a while loop (or better still a do-while loop) is better suited.</p>

<p>Finally creating one liner functions to encapsulate system.out.print and println seem more effort than is necessary. </p>",19253202,0,java|arrays|printing|element
How to print elements from an array list,"<p>I've looked online for help so far and nothing is working for me. This is what I have right now, can you please tell me what is wrong with it?</p>

<p>import java.util.*;</p>

<pre><code>class employeeProgram{

    public static void main(String[] args){

            for (int count = 0; count &lt; 1; ){

                    Scanner input = new Scanner(System.in);

                    ArrayList&lt;String&gt; employeeNames = new ArrayList&lt;String&gt;();

                    String commnd;

                    print(""What would you like to do? (Add, Remove, List, Exit): "");

                    commnd = input.next();

                    if (""Add"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to add to the list: "");
                            employeeNames.add(input.next());


                    } else if (""Remove"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to remove from the list: "");

                            employeeNames.remove(input.next());

                    } else if (""List"".equals(commnd)){

                            for (int j = 0; j &lt; employeeNames.size(); j++){

                                    println(employeeNames.get(j));
                                    println(j);

                            }


                            //println(employeeNames);

                    } else if (""Exit"".equals(commnd)){

                            input.close();
                            break;

                    } else {

                            println(""Invalid command."");

                    }
            }
    }
    public static void println(Object x){

            System.out.println(x);

    }
    public static void print(Object x){

            System.out.print(x);

    }

}
</code></pre>

<p>The for loop isn't beginning, I know that much because the ""println(j)"" wasn't working either. When I tried the part that I've commented out, all I got from typing list was ""[]"" and nothing else. I'm a beginner, and this is my first program using ArrayLists, so thanks in advance to anyone who decides to help me out :)</p>","<p>I would try something else instead of the for loop:</p>

<p>Although what you have here might technically work, for...loops are for deterministic processes.  Here you are using it as an infinite loop that you hope to force break at a later point.  This is dangerous and could lead to bugs.</p>

<p>I'd change this:</p>

<pre><code>for (int count = 0; count &lt; 1; ){
</code></pre>

<p>to this:</p>

<pre><code> bool done = false;
 while(!done) {
</code></pre>

<p>Then, later, when you want to break out.  issue this line:</p>

<pre><code> done = true;
</code></pre>",19253202,0,java|arrays|printing|element
How to print elements from an array list,"<p>I've looked online for help so far and nothing is working for me. This is what I have right now, can you please tell me what is wrong with it?</p>

<p>import java.util.*;</p>

<pre><code>class employeeProgram{

    public static void main(String[] args){

            for (int count = 0; count &lt; 1; ){

                    Scanner input = new Scanner(System.in);

                    ArrayList&lt;String&gt; employeeNames = new ArrayList&lt;String&gt;();

                    String commnd;

                    print(""What would you like to do? (Add, Remove, List, Exit): "");

                    commnd = input.next();

                    if (""Add"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to add to the list: "");
                            employeeNames.add(input.next());


                    } else if (""Remove"".equals(commnd)){

                            print(""Enter the name of the employee you'd like to remove from the list: "");

                            employeeNames.remove(input.next());

                    } else if (""List"".equals(commnd)){

                            for (int j = 0; j &lt; employeeNames.size(); j++){

                                    println(employeeNames.get(j));
                                    println(j);

                            }


                            //println(employeeNames);

                    } else if (""Exit"".equals(commnd)){

                            input.close();
                            break;

                    } else {

                            println(""Invalid command."");

                    }
            }
    }
    public static void println(Object x){

            System.out.println(x);

    }
    public static void print(Object x){

            System.out.print(x);

    }

}
</code></pre>

<p>The for loop isn't beginning, I know that much because the ""println(j)"" wasn't working either. When I tried the part that I've commented out, all I got from typing list was ""[]"" and nothing else. I'm a beginner, and this is my first program using ArrayLists, so thanks in advance to anyone who decides to help me out :)</p>",<p>Define your <code>employeeNames</code>  List outside the first <code>for</code> loop. ArrayList is getting re-intialized with every iteration of the loop.</p>,19253202,2,java|arrays|printing|element
How to check for equal words in string array in JAVA,"<p>This should be quite simple (I think), but I just can't get it right...:|</p>

<p>The task is as follows:</p>

<p>Ask the user for some input. The input must be split in to single words and put into an array. All words should be counted. If equal words exists, they get a ""+1"" on the output. 
Finally I want to print out and hopefully the right amount of counted words in a list. I got the first two columns right, but the word-counter of equal words gave me a headache. If a word is found to be equal, it mustnt appear twice in the generated list! :!</p>

<p>I am a complete JAVA newbie so please be kind on the code-judging. ;)</p>

<p>Here is my code so far:</p>

<pre><code>package MyProjects;

import javax.swing.JOptionPane;

public class MyWordCount {
public static void main(String[] args) {

    //User input dialog
    String inPut = JOptionPane.showInputDialog(""Write som text here"");

    //Puts it into an array, and split it with "" "".
    String[] wordList = inPut.split("" "");

    //Print to screen
    System.out.println(""Place:\tWord:\tCount: "");

    //Check &amp; init wordCount
    int wordCount = 0;

    for (int i = 0; i &lt; wordList.length; i++) {

        for (int j = 0; j &lt; wordList.length; j++){

            //some code here to compare
            //something.compareTo(wordList) ?

        }

        System.out.println(i + ""\t"" + wordList[i]+ ""\t"" + wordCount[?] );
    }

}
}
</code></pre>","<p>Thanks for trying to help me. -This is what I ended up doing: </p>

<pre><code>import java.util.ArrayList;

import javax.swing.JOptionPane;

public class MyWordCount {
public static void main(String[] args) {

    // Text in
    String inText = JOptionPane.showInputDialog(""Write some text here"");

    // Puts it into an array, and splits
    String[] wordlist = inText.split("" "");

    // Text out (Header)
    System.out.println(""Place:\tWord:\tNo. of Words: "");

    // declare Arraylist for words
    ArrayList&lt;String&gt; wordEncounter = new ArrayList&lt;String&gt;();
    ArrayList&lt;Integer&gt; numberEncounter = new ArrayList&lt;Integer&gt;();

    // Checks number of encounters of words
    for (int i = 0; i &lt; wordlist.length; i++) {
        String word = wordlist[i];

        // Make everything lowercase just for ease...
        word = word.toLowerCase();

        if (wordEncounter.contains(word)) {
            // Checks word encounter - return index of word
            int position = wordEncounter.indexOf(word);
            Integer number = numberEncounter.get(position);
            int number_int = number.intValue();
            number_int++;
            number = new Integer(number_int);
            numberEncounter.set(position, number);

            // Number of encounters - add 1;
        } else {
            wordEncounter.add(word);
            numberEncounter.add(new Integer(1));
        }

    }

    // Text out (the list of words)
    for (int i = 0; i &lt; wordEncounter.size(); i++) {
        System.out.println(i + ""\t"" + wordEncounter.get(i) + ""\t""
                + numberEncounter.get(i));
    }

  }
}
</code></pre>",12377803,0,java|arrays|string|sorting
How to check for equal words in string array in JAVA,"<p>This should be quite simple (I think), but I just can't get it right...:|</p>

<p>The task is as follows:</p>

<p>Ask the user for some input. The input must be split in to single words and put into an array. All words should be counted. If equal words exists, they get a ""+1"" on the output. 
Finally I want to print out and hopefully the right amount of counted words in a list. I got the first two columns right, but the word-counter of equal words gave me a headache. If a word is found to be equal, it mustnt appear twice in the generated list! :!</p>

<p>I am a complete JAVA newbie so please be kind on the code-judging. ;)</p>

<p>Here is my code so far:</p>

<pre><code>package MyProjects;

import javax.swing.JOptionPane;

public class MyWordCount {
public static void main(String[] args) {

    //User input dialog
    String inPut = JOptionPane.showInputDialog(""Write som text here"");

    //Puts it into an array, and split it with "" "".
    String[] wordList = inPut.split("" "");

    //Print to screen
    System.out.println(""Place:\tWord:\tCount: "");

    //Check &amp; init wordCount
    int wordCount = 0;

    for (int i = 0; i &lt; wordList.length; i++) {

        for (int j = 0; j &lt; wordList.length; j++){

            //some code here to compare
            //something.compareTo(wordList) ?

        }

        System.out.println(i + ""\t"" + wordList[i]+ ""\t"" + wordCount[?] );
    }

}
}
</code></pre>","<pre><code>import java.util.ArrayList;
import java.util.regex.PatternSyntaxException;

import javax.swing.JOptionPane;

public class Main {

/**
 * @param args
 */
public static void main(String[] args) {

    //Print to screen
    System.out.println(""Place:\tWord:\tCount: "");

    //User input dialog
    String inPut = JOptionPane.showInputDialog(""Write som text here"");

    //Puts it into an array, and split it with "" "".
    String[] wordList;
    try{
        wordList = inPut.split("" "");
    }catch(PatternSyntaxException e) {
        // catch the buggy!
        System.out.println(""Ooops.. ""+e.getMessage());
        return;
    }catch(NullPointerException n) {
        System.out.println(""cancelled! exitting.."");
        return;
    }

    ArrayList&lt;String&gt; allWords = new ArrayList&lt;String&gt;();
    for(String word : wordList) {
        allWords.add(word);
    }

    // reset unique words counter
    int uniqueWordCount = 0;

    // Remove all of the words
    while(allWords.size() &gt; 0) {
        // reset the word counter
        int count = 0;

        // get the next word
        String activeWord = allWords.get(0);

        // Remove all instances of this word
        while(doesContainThisWord(allWords, activeWord)) {
            allWords.remove(activeWord);
            count++;
        }

        // increase the unique word count;
        uniqueWordCount++;

        // print result.
        System.out.println(uniqueWordCount + ""\t"" + activeWord + ""\t"" + count );

    }

}

/**
 * This function returns true if the parameters are not null and the array contains an equal string to newWord.
 */
public static boolean doesContainThisWord(ArrayList&lt;String&gt; wordList, String newWord) {
    // Just checking...
    if (wordList == null || newWord == null) {
        return false;
    }

    // Loop through the list of words
    for (String oldWord : wordList) {
        if (oldWord.equals(newWord)) {
            // gotcha!
            return true;
        }
    }
    return false;
}

}
</code></pre>",12377803,1,java|arrays|string|sorting
How to check for equal words in string array in JAVA,"<p>This should be quite simple (I think), but I just can't get it right...:|</p>

<p>The task is as follows:</p>

<p>Ask the user for some input. The input must be split in to single words and put into an array. All words should be counted. If equal words exists, they get a ""+1"" on the output. 
Finally I want to print out and hopefully the right amount of counted words in a list. I got the first two columns right, but the word-counter of equal words gave me a headache. If a word is found to be equal, it mustnt appear twice in the generated list! :!</p>

<p>I am a complete JAVA newbie so please be kind on the code-judging. ;)</p>

<p>Here is my code so far:</p>

<pre><code>package MyProjects;

import javax.swing.JOptionPane;

public class MyWordCount {
public static void main(String[] args) {

    //User input dialog
    String inPut = JOptionPane.showInputDialog(""Write som text here"");

    //Puts it into an array, and split it with "" "".
    String[] wordList = inPut.split("" "");

    //Print to screen
    System.out.println(""Place:\tWord:\tCount: "");

    //Check &amp; init wordCount
    int wordCount = 0;

    for (int i = 0; i &lt; wordList.length; i++) {

        for (int j = 0; j &lt; wordList.length; j++){

            //some code here to compare
            //something.compareTo(wordList) ?

        }

        System.out.println(i + ""\t"" + wordList[i]+ ""\t"" + wordCount[?] );
    }

}
}
</code></pre>","<p>Here's a solution using a map of WordInfo objects that records locations of the words within the text and uses that as a count. The LinkedHashMap preserves the order of keys from when they are first entered so simply iterating through the keys gives you the ""cast in order of appearance""</p>

<p>You can make this case insensitive while preserving the case of the first appearance by storing all keys as lower case but storing the original case in the WordInfo object. Or just convert all words to lower case and leave it at that.
You may also want to think about removing all <code>,</code> / <code>.</code> / <code>""</code> etc from the first text before splitting, but you'll never get that perfect anyway.</p>

<pre><code>import java.util.LinkedHashMap;
import java.util.Map;

import javax.swing.JOptionPane;

public class MyWordCount {
    public static void main(String[] args) {

        //User input dialog
        String inPut = JOptionPane.showInputDialog(""Write som text here"");

        Map&lt;String,WordInfo&gt; wordMap = new LinkedHashMap&lt;String,WordInfo&gt;();

        //Puts it into an array, and split it with "" "".
        String[] wordList = inPut.split("" "");

        for (int i = 0; i &lt; wordList.length; i++) {
            String word = wordList[i];
            WordInfo wi = wordMap.get(word);
            if (wi == null) {
                wi = new WordInfo();            
            }
            wi.addPlace(i+1);
            wordMap.put(word,wi);           
        }

        //Print to screen

        System.out.println(""Place:\tWord:\tCount: "");

        for (String word : wordMap.keySet()) {          

            WordInfo wi = wordMap.get(word);        
            System.out.println(wi.places() + ""\t"" + word + ""\t"" + wi.count());
        }

      }
}
</code></pre>

<p>And the WordInfo class:</p>

<pre><code>import java.util.ArrayList;
import java.util.List;

public class WordInfo {

    private List&lt;Integer&gt; places;

    public WordInfo() {
        this.places = new ArrayList&lt;&gt;();
    }

    public void addPlace(int place) {
        this.places.add(place);
    }


    public int count() {
        return this.places.size();
    }

    public String places() {
        if (places.size() == 0)
            return """";

        String result = """";
        for (Integer place : this.places) {
            result += "", "" + place;
        }
        result = result.substring(2, result.length());
        return result;
    }
}
</code></pre>",12377803,1,java|arrays|string|sorting
How to check for equal words in string array in JAVA,"<p>This should be quite simple (I think), but I just can't get it right...:|</p>

<p>The task is as follows:</p>

<p>Ask the user for some input. The input must be split in to single words and put into an array. All words should be counted. If equal words exists, they get a ""+1"" on the output. 
Finally I want to print out and hopefully the right amount of counted words in a list. I got the first two columns right, but the word-counter of equal words gave me a headache. If a word is found to be equal, it mustnt appear twice in the generated list! :!</p>

<p>I am a complete JAVA newbie so please be kind on the code-judging. ;)</p>

<p>Here is my code so far:</p>

<pre><code>package MyProjects;

import javax.swing.JOptionPane;

public class MyWordCount {
public static void main(String[] args) {

    //User input dialog
    String inPut = JOptionPane.showInputDialog(""Write som text here"");

    //Puts it into an array, and split it with "" "".
    String[] wordList = inPut.split("" "");

    //Print to screen
    System.out.println(""Place:\tWord:\tCount: "");

    //Check &amp; init wordCount
    int wordCount = 0;

    for (int i = 0; i &lt; wordList.length; i++) {

        for (int j = 0; j &lt; wordList.length; j++){

            //some code here to compare
            //something.compareTo(wordList) ?

        }

        System.out.println(i + ""\t"" + wordList[i]+ ""\t"" + wordCount[?] );
    }

}
}
</code></pre>","<p>So in order to compare two strings, you do:</p>

<pre><code>String stringOne = ""Hello"";
String stringTwo = ""World"";
stringOne.compareTo(stringTwo);
//Or you can do
stringTwo.compareTo(stringOne); 
</code></pre>

<p>You can't compare a String to a String array like in your comment. You would have to take an element in this string array, and compare that (So stringArray[elementNumber]).</p>

<p>For counting how many words there are, if you are determining the number of repeated words, you would want to have an array of integers (So make a new int[]). Each place in the new int[] should correspond to the word in your array of words. This would allow you to count the number of times a word is repeated.</p>",12377803,2,java|arrays|string|sorting
How to sort file names in ascending order?,"<p>I have a set of files in a folder, and all of them starting with a similar name, except one. Here is an example:</p>

<pre><code>Coordinate.txt
Spectrum_1.txt
Spectrum_2.txt
Spectrum_3.txt
.
.
.
Spectrum_11235
</code></pre>

<p>I am able to list all the files from the specified folder, but the list is not in an ascending order of the spectrum number. Example: I get the following result when the program is executed:</p>

<pre><code>Spectrum_999.txt
Spectrum_9990.txt
Spectrum_9991.txt
Spectrum_9992.txt
Spectrum_9993.txt
Spectrum_9994.txt
Spectrum_9995.txt
Spectrum_9996.txt
Spectrum_9997.txt
Spectrum_9998.txt
Spectrum_9999.txt
</code></pre>

<p>But this order is not correct. There should be Spectrum_1000.txt file after Spectrum_999.txt. Can anyone help? Here is the code:</p>

<pre><code>import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

    public class FileInput {

        public void userInput()
        {
            Scanner scanner = new Scanner( System.in );
            System.out.println(""Enter the file path: "");
            String dirPath = scanner.nextLine(); // Takes the directory path as the user input

            File folder = new File(dirPath);
            if(folder.isDirectory())
            {
                File[] fileList = folder.listFiles();

                Arrays.sort(fileList);

                System.out.println(""\nTotal number of items present in the directory: "" + fileList.length );


                // Lists only files since we have applied file filter
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

                // Creating a filter to return only files.
                FileFilter fileFilter = new FileFilter()
                {
                    @Override
                    public boolean accept(File file) {
                        return !file.isDirectory();
                    }
                };

                fileList = folder.listFiles(fileFilter);

                // Sort files by name
                Arrays.sort(fileList, new Comparator()
                {
                    @Override
                    public int compare(Object f1, Object f2) {
                        return ((File) f1).getName().compareTo(((File) f2).getName());
                    }
                });

                //Prints the files in file name ascending order
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

            }   
        }
    }
</code></pre>","<p>Just another way to do it, but using the power of java8</p>

<pre><code>List&lt;Path&gt; x = Files.list(Paths.get(""C:\\myPath\\Tools""))
            .filter(p -&gt; Files.exists(p))
            .map(s -&gt; s.getFileName())
            .sorted()
            .collect(Collectors.toList());

x.forEach(System.out::println);
</code></pre>",16898029,-1,java|file|sorting|arraylist
How to sort file names in ascending order?,"<p>I have a set of files in a folder, and all of them starting with a similar name, except one. Here is an example:</p>

<pre><code>Coordinate.txt
Spectrum_1.txt
Spectrum_2.txt
Spectrum_3.txt
.
.
.
Spectrum_11235
</code></pre>

<p>I am able to list all the files from the specified folder, but the list is not in an ascending order of the spectrum number. Example: I get the following result when the program is executed:</p>

<pre><code>Spectrum_999.txt
Spectrum_9990.txt
Spectrum_9991.txt
Spectrum_9992.txt
Spectrum_9993.txt
Spectrum_9994.txt
Spectrum_9995.txt
Spectrum_9996.txt
Spectrum_9997.txt
Spectrum_9998.txt
Spectrum_9999.txt
</code></pre>

<p>But this order is not correct. There should be Spectrum_1000.txt file after Spectrum_999.txt. Can anyone help? Here is the code:</p>

<pre><code>import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

    public class FileInput {

        public void userInput()
        {
            Scanner scanner = new Scanner( System.in );
            System.out.println(""Enter the file path: "");
            String dirPath = scanner.nextLine(); // Takes the directory path as the user input

            File folder = new File(dirPath);
            if(folder.isDirectory())
            {
                File[] fileList = folder.listFiles();

                Arrays.sort(fileList);

                System.out.println(""\nTotal number of items present in the directory: "" + fileList.length );


                // Lists only files since we have applied file filter
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

                // Creating a filter to return only files.
                FileFilter fileFilter = new FileFilter()
                {
                    @Override
                    public boolean accept(File file) {
                        return !file.isDirectory();
                    }
                };

                fileList = folder.listFiles(fileFilter);

                // Sort files by name
                Arrays.sort(fileList, new Comparator()
                {
                    @Override
                    public int compare(Object f1, Object f2) {
                        return ((File) f1).getName().compareTo(((File) f2).getName());
                    }
                });

                //Prints the files in file name ascending order
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

            }   
        }
    }
</code></pre>","<p>You can find solution to your problem in comment above, but taking into consideration that only link had been published I'm giving code from that site. Worked great.</p>

<ol>
<li><p><strong>You need to create your own AlphanumericalComparator.</strong></p>

<pre><code> import java.io.File;
 import java.util.Comparator;

public class AlphanumFileComparator implements Comparator
{

   private final boolean isDigit(char ch)
   {
    return ch &gt;= 48 &amp;&amp; ch &lt;= 57;
   }


private final String getChunk(String s, int slength, int marker)
{
    StringBuilder chunk = new StringBuilder();
    char c = s.charAt(marker);
    chunk.append(c);
    marker++;
    if (isDigit(c))
    {
        while (marker &lt; slength)
        {
            c = s.charAt(marker);
            if (!isDigit(c))
                break;
            chunk.append(c);
            marker++;
        }
    } else
    {
        while (marker &lt; slength)
        {
            c = s.charAt(marker);
            if (isDigit(c))
                break;
            chunk.append(c);
            marker++;
        }
    }
    return chunk.toString();
}

public int compare(Object o1, Object o2)
{
    if (!(o1 instanceof File) || !(o2 instanceof File))
    {
        return 0;
    }
    File f1 = (File)o1;
    File f2 = (File)o2;
    String s1 = f1.getName();
    String s2 = f2.getName();

    int thisMarker = 0;
    int thatMarker = 0;
    int s1Length = s1.length();
    int s2Length = s2.length();

    while (thisMarker &lt; s1Length &amp;&amp; thatMarker &lt; s2Length)
    {
        String thisChunk = getChunk(s1, s1Length, thisMarker);
        thisMarker += thisChunk.length();

        String thatChunk = getChunk(s2, s2Length, thatMarker);
        thatMarker += thatChunk.length();

        /** If both chunks contain numeric characters, sort them numerically **/

        int result = 0;
        if (isDigit(thisChunk.charAt(0)) &amp;&amp; isDigit(thatChunk.charAt(0)))
        {
            // Simple chunk comparison by length.
            int thisChunkLength = thisChunk.length();
            result = thisChunkLength - thatChunk.length();
            // If equal, the first different number counts
            if (result == 0)
            {
                for (int i = 0; i &lt; thisChunkLength; i++)
                {
                    result = thisChunk.charAt(i) - thatChunk.charAt(i);
                    if (result != 0)
                    {
                        return result;
                    }
                }
            }
        } else
        {
            result = thisChunk.compareTo(thatChunk);
        }

        if (result != 0)
            return result;
    }

    return s1Length - s2Length;
}
}
</code></pre></li>
</ol>

<p><strong>2. Sort your files, depending on this class.</strong></p>

<pre><code>     File[] listOfFiles = rootFolder.listFiles();
     Arrays.sort(listOfFiles, new AlphanumFileComparator() );
     ...to sth with your files.
</code></pre>

<p>Hope it helps. It worked for me, like a charm.</p>

<p>Solution from: <a href=""http://www.davekoelle.com/files/AlphanumComparator.java"" rel=""nofollow noreferrer"">http://www.davekoelle.com/files/AlphanumComparator.java</a> <a href=""http://www.davekoelle.com/files/AlphanumComparator.java"" rel=""nofollow noreferrer"">here</a></p>",16898029,3,java|file|sorting|arraylist
How to sort file names in ascending order?,"<p>I have a set of files in a folder, and all of them starting with a similar name, except one. Here is an example:</p>

<pre><code>Coordinate.txt
Spectrum_1.txt
Spectrum_2.txt
Spectrum_3.txt
.
.
.
Spectrum_11235
</code></pre>

<p>I am able to list all the files from the specified folder, but the list is not in an ascending order of the spectrum number. Example: I get the following result when the program is executed:</p>

<pre><code>Spectrum_999.txt
Spectrum_9990.txt
Spectrum_9991.txt
Spectrum_9992.txt
Spectrum_9993.txt
Spectrum_9994.txt
Spectrum_9995.txt
Spectrum_9996.txt
Spectrum_9997.txt
Spectrum_9998.txt
Spectrum_9999.txt
</code></pre>

<p>But this order is not correct. There should be Spectrum_1000.txt file after Spectrum_999.txt. Can anyone help? Here is the code:</p>

<pre><code>import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

    public class FileInput {

        public void userInput()
        {
            Scanner scanner = new Scanner( System.in );
            System.out.println(""Enter the file path: "");
            String dirPath = scanner.nextLine(); // Takes the directory path as the user input

            File folder = new File(dirPath);
            if(folder.isDirectory())
            {
                File[] fileList = folder.listFiles();

                Arrays.sort(fileList);

                System.out.println(""\nTotal number of items present in the directory: "" + fileList.length );


                // Lists only files since we have applied file filter
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

                // Creating a filter to return only files.
                FileFilter fileFilter = new FileFilter()
                {
                    @Override
                    public boolean accept(File file) {
                        return !file.isDirectory();
                    }
                };

                fileList = folder.listFiles(fileFilter);

                // Sort files by name
                Arrays.sort(fileList, new Comparator()
                {
                    @Override
                    public int compare(Object f1, Object f2) {
                        return ((File) f1).getName().compareTo(((File) f2).getName());
                    }
                });

                //Prints the files in file name ascending order
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

            }   
        }
    }
</code></pre>","<p>The <a href=""https://stackoverflow.com/a/16898539/521799"">currently accepted answer</a> does this only for numeric suffixes of files that are always called the same name (i.e. ignoring the prefix).</p>

<p><a href=""https://blog.jooq.org/2018/02/23/how-to-order-file-names-semantically-in-java/"" rel=""nofollow noreferrer"">A much more generic solution, which I blogged about here</a>, works with any file name, splitting names in segments and ordering the segments numerically (if both segments are numbers) or lexicographically, otherwise. <a href=""https://codereview.stackexchange.com/a/37217/5314"">Idea inspired from this answer</a>:</p>

<pre><code>public final class FilenameComparator implements Comparator&lt;String&gt; {
    private static final Pattern NUMBERS = 
        Pattern.compile(""(?&lt;=\\D)(?=\\d)|(?&lt;=\\d)(?=\\D)"");
    @Override public final int compare(String o1, String o2) {
        // Optional ""NULLS LAST"" semantics:
        if (o1 == null || o2 == null)
            return o1 == null ? o2 == null ? 0 : -1 : 1;

        // Splitting both input strings by the above patterns
        String[] split1 = NUMBERS.split(o1);
        String[] split2 = NUMBERS.split(o2);
        for (int i = 0; i &lt; Math.min(split1.length, split2.length); i++) {
            char c1 = split1[i].charAt(0);
            char c2 = split2[i].charAt(0);
            int cmp = 0;

            // If both segments start with a digit, sort them numerically using 
            // BigInteger to stay safe
            if (c1 &gt;= '0' &amp;&amp; c1 &lt;= '9' &amp;&amp; c2 &gt;= '0' &amp;&amp; c2 &lt;= '9')
                cmp = new BigInteger(split1[i]).compareTo(new BigInteger(split2[i]));

            // If we haven't sorted numerically before, or if numeric sorting yielded 
            // equality (e.g 007 and 7) then sort lexicographically
            if (cmp == 0)
                cmp = split1[i].compareTo(split2[i]);

            // Abort once some prefix has unequal ordering
            if (cmp != 0)
                return cmp;
        }

        // If we reach this, then both strings have equally ordered prefixes, but 
        // maybe one string is longer than the other (i.e. has more segments)
        return split1.length - split2.length;
    }
}
</code></pre>

<p>This can also handle version with subversions, e.g. things like <code>version-1.2.3.txt</code></p>",16898029,6,java|file|sorting|arraylist
How to sort file names in ascending order?,"<p>I have a set of files in a folder, and all of them starting with a similar name, except one. Here is an example:</p>

<pre><code>Coordinate.txt
Spectrum_1.txt
Spectrum_2.txt
Spectrum_3.txt
.
.
.
Spectrum_11235
</code></pre>

<p>I am able to list all the files from the specified folder, but the list is not in an ascending order of the spectrum number. Example: I get the following result when the program is executed:</p>

<pre><code>Spectrum_999.txt
Spectrum_9990.txt
Spectrum_9991.txt
Spectrum_9992.txt
Spectrum_9993.txt
Spectrum_9994.txt
Spectrum_9995.txt
Spectrum_9996.txt
Spectrum_9997.txt
Spectrum_9998.txt
Spectrum_9999.txt
</code></pre>

<p>But this order is not correct. There should be Spectrum_1000.txt file after Spectrum_999.txt. Can anyone help? Here is the code:</p>

<pre><code>import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

    public class FileInput {

        public void userInput()
        {
            Scanner scanner = new Scanner( System.in );
            System.out.println(""Enter the file path: "");
            String dirPath = scanner.nextLine(); // Takes the directory path as the user input

            File folder = new File(dirPath);
            if(folder.isDirectory())
            {
                File[] fileList = folder.listFiles();

                Arrays.sort(fileList);

                System.out.println(""\nTotal number of items present in the directory: "" + fileList.length );


                // Lists only files since we have applied file filter
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

                // Creating a filter to return only files.
                FileFilter fileFilter = new FileFilter()
                {
                    @Override
                    public boolean accept(File file) {
                        return !file.isDirectory();
                    }
                };

                fileList = folder.listFiles(fileFilter);

                // Sort files by name
                Arrays.sort(fileList, new Comparator()
                {
                    @Override
                    public int compare(Object f1, Object f2) {
                        return ((File) f1).getName().compareTo(((File) f2).getName());
                    }
                });

                //Prints the files in file name ascending order
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

            }   
        }
    }
</code></pre>","<pre><code>Arrays.sort(fileList, new Comparator()
{
    @Override
    public int compare(Object f1, Object f2) {
        String fileName1 = ((File) f1).getName();
        String fileName2 = ((File) f1).getName();

        int fileId1 = Integer.parseInt(fileName1.split(""_"")[1]);
        int fileId2 = Integer.parseInt(fileName2.split(""_"")[1]);

        return fileId1 - fileId2;
    }
});
</code></pre>

<p>make sure to handle files that does not has _ in the name</p>",16898029,1,java|file|sorting|arraylist
How to sort file names in ascending order?,"<p>I have a set of files in a folder, and all of them starting with a similar name, except one. Here is an example:</p>

<pre><code>Coordinate.txt
Spectrum_1.txt
Spectrum_2.txt
Spectrum_3.txt
.
.
.
Spectrum_11235
</code></pre>

<p>I am able to list all the files from the specified folder, but the list is not in an ascending order of the spectrum number. Example: I get the following result when the program is executed:</p>

<pre><code>Spectrum_999.txt
Spectrum_9990.txt
Spectrum_9991.txt
Spectrum_9992.txt
Spectrum_9993.txt
Spectrum_9994.txt
Spectrum_9995.txt
Spectrum_9996.txt
Spectrum_9997.txt
Spectrum_9998.txt
Spectrum_9999.txt
</code></pre>

<p>But this order is not correct. There should be Spectrum_1000.txt file after Spectrum_999.txt. Can anyone help? Here is the code:</p>

<pre><code>import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

    public class FileInput {

        public void userInput()
        {
            Scanner scanner = new Scanner( System.in );
            System.out.println(""Enter the file path: "");
            String dirPath = scanner.nextLine(); // Takes the directory path as the user input

            File folder = new File(dirPath);
            if(folder.isDirectory())
            {
                File[] fileList = folder.listFiles();

                Arrays.sort(fileList);

                System.out.println(""\nTotal number of items present in the directory: "" + fileList.length );


                // Lists only files since we have applied file filter
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

                // Creating a filter to return only files.
                FileFilter fileFilter = new FileFilter()
                {
                    @Override
                    public boolean accept(File file) {
                        return !file.isDirectory();
                    }
                };

                fileList = folder.listFiles(fileFilter);

                // Sort files by name
                Arrays.sort(fileList, new Comparator()
                {
                    @Override
                    public int compare(Object f1, Object f2) {
                        return ((File) f1).getName().compareTo(((File) f2).getName());
                    }
                });

                //Prints the files in file name ascending order
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

            }   
        }
    }
</code></pre>","<p>What you are asking for is numerical sort. You need implement a <a href=""http://docs.oracle.com/javase/6/docs/api/java/util/Comparator.html"" rel=""noreferrer"">Comparator</a> and pass it to the <a href=""http://docs.oracle.com/javase/6/docs/api/java/util/Arrays.html#sort%28T%5B%5D,%20java.util.Comparator%29"" rel=""noreferrer"">Arrays#sort</a> method. In the compare method you need to extract the number from each filename an then compare the numbers.</p>

<p>The reason why you get the output you are getting now is that sorting happens <a href=""https://stackoverflow.com/questions/5167928/what-is-natural-ordering-when-we-talk-about-sorting"">alphanumerically</a></p>

<p>Here a is a very basic way of doing it. This code uses simple <code>String</code>-operation to extract the numbers. This works if you know the format of the filename, in your case <code>Spectrum_&lt;number&gt;.txt</code>. A better way of doing the extraction is to use <a href=""http://docs.oracle.com/javase/tutorial/essential/regex/"" rel=""noreferrer"">regular expression</a>.</p>

<pre><code>public class FileNameNumericSort {

    private final static File[] files = {
        new File(""Spectrum_1.txt""),
        new File(""Spectrum_14.txt""),
        new File(""Spectrum_2.txt""),
        new File(""Spectrum_7.txt""),     
        new File(""Spectrum_1000.txt""), 
        new File(""Spectrum_999.txt""), 
        new File(""Spectrum_9990.txt""), 
        new File(""Spectrum_9991.txt""), 
    };

    @Test
    public void sortByNumber() {
        Arrays.sort(files, new Comparator&lt;File&gt;() {
            @Override
            public int compare(File o1, File o2) {
                int n1 = extractNumber(o1.getName());
                int n2 = extractNumber(o2.getName());
                return n1 - n2;
            }

            private int extractNumber(String name) {
                int i = 0;
                try {
                    int s = name.indexOf('_')+1;
                    int e = name.lastIndexOf('.');
                    String number = name.substring(s, e);
                    i = Integer.parseInt(number);
                } catch(Exception e) {
                    i = 0; // if filename does not match the format
                           // then default to 0
                }
                return i;
            }
        });

        for(File f : files) {
            System.out.println(f.getName());
        }
    }
}
</code></pre>

<p><strong>Output</strong></p>

<pre><code>Spectrum_1.txt
Spectrum_2.txt
Spectrum_7.txt
Spectrum_14.txt
Spectrum_999.txt
Spectrum_1000.txt
Spectrum_9990.txt
Spectrum_9991.txt
</code></pre>",16898029,31,java|file|sorting|arraylist
How to sort file names in ascending order?,"<p>I have a set of files in a folder, and all of them starting with a similar name, except one. Here is an example:</p>

<pre><code>Coordinate.txt
Spectrum_1.txt
Spectrum_2.txt
Spectrum_3.txt
.
.
.
Spectrum_11235
</code></pre>

<p>I am able to list all the files from the specified folder, but the list is not in an ascending order of the spectrum number. Example: I get the following result when the program is executed:</p>

<pre><code>Spectrum_999.txt
Spectrum_9990.txt
Spectrum_9991.txt
Spectrum_9992.txt
Spectrum_9993.txt
Spectrum_9994.txt
Spectrum_9995.txt
Spectrum_9996.txt
Spectrum_9997.txt
Spectrum_9998.txt
Spectrum_9999.txt
</code></pre>

<p>But this order is not correct. There should be Spectrum_1000.txt file after Spectrum_999.txt. Can anyone help? Here is the code:</p>

<pre><code>import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

    public class FileInput {

        public void userInput()
        {
            Scanner scanner = new Scanner( System.in );
            System.out.println(""Enter the file path: "");
            String dirPath = scanner.nextLine(); // Takes the directory path as the user input

            File folder = new File(dirPath);
            if(folder.isDirectory())
            {
                File[] fileList = folder.listFiles();

                Arrays.sort(fileList);

                System.out.println(""\nTotal number of items present in the directory: "" + fileList.length );


                // Lists only files since we have applied file filter
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

                // Creating a filter to return only files.
                FileFilter fileFilter = new FileFilter()
                {
                    @Override
                    public boolean accept(File file) {
                        return !file.isDirectory();
                    }
                };

                fileList = folder.listFiles(fileFilter);

                // Sort files by name
                Arrays.sort(fileList, new Comparator()
                {
                    @Override
                    public int compare(Object f1, Object f2) {
                        return ((File) f1).getName().compareTo(((File) f2).getName());
                    }
                });

                //Prints the files in file name ascending order
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

            }   
        }
    }
</code></pre>","<p>you can use <code>Collections.sort(fileList);</code>  to sort arraylist.</p>

<p>Then use</p>

<pre><code> for(File file:fileList)                
         System.out.println(file.getName());
</code></pre>

<p><a href=""http://docs.oracle.com/javase/6/docs/api/java/util/Collections.html#sort%28java.util.List%29"" rel=""nofollow""><code>Collections.sort()</code></a></p>",16898029,-1,java|file|sorting|arraylist
How to sort file names in ascending order?,"<p>I have a set of files in a folder, and all of them starting with a similar name, except one. Here is an example:</p>

<pre><code>Coordinate.txt
Spectrum_1.txt
Spectrum_2.txt
Spectrum_3.txt
.
.
.
Spectrum_11235
</code></pre>

<p>I am able to list all the files from the specified folder, but the list is not in an ascending order of the spectrum number. Example: I get the following result when the program is executed:</p>

<pre><code>Spectrum_999.txt
Spectrum_9990.txt
Spectrum_9991.txt
Spectrum_9992.txt
Spectrum_9993.txt
Spectrum_9994.txt
Spectrum_9995.txt
Spectrum_9996.txt
Spectrum_9997.txt
Spectrum_9998.txt
Spectrum_9999.txt
</code></pre>

<p>But this order is not correct. There should be Spectrum_1000.txt file after Spectrum_999.txt. Can anyone help? Here is the code:</p>

<pre><code>import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.Scanner;

    public class FileInput {

        public void userInput()
        {
            Scanner scanner = new Scanner( System.in );
            System.out.println(""Enter the file path: "");
            String dirPath = scanner.nextLine(); // Takes the directory path as the user input

            File folder = new File(dirPath);
            if(folder.isDirectory())
            {
                File[] fileList = folder.listFiles();

                Arrays.sort(fileList);

                System.out.println(""\nTotal number of items present in the directory: "" + fileList.length );


                // Lists only files since we have applied file filter
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

                // Creating a filter to return only files.
                FileFilter fileFilter = new FileFilter()
                {
                    @Override
                    public boolean accept(File file) {
                        return !file.isDirectory();
                    }
                };

                fileList = folder.listFiles(fileFilter);

                // Sort files by name
                Arrays.sort(fileList, new Comparator()
                {
                    @Override
                    public int compare(Object f1, Object f2) {
                        return ((File) f1).getName().compareTo(((File) f2).getName());
                    }
                });

                //Prints the files in file name ascending order
                for(File file:fileList)
                {
                    System.out.println(file.getName());
                }

            }   
        }
    }
</code></pre>","<p>The <code>NameFileComparator</code> class available in Commons IO library that have feature for sorting file array by name,last modified date, size and many more.Files can be sorted in ascending and descending order, with case sensitivity or case insensitivity.</p>

<p>Import : </p>

<p><code>org.apache.commons.io.comparator.NameFileComparator </code></p>

<p>Code :</p>

<pre><code>File directory = new File(""."");
File[] files = directory.listFiles();
Arrays.sort(files, NameFileComparator.NAME_COMPARATOR)
</code></pre>",16898029,4,java|file|sorting|arraylist
How to sort ArrayList according to another ArrayList?,"<p>I've got two <code>ArrayList&lt;JLabel&gt;</code>:</p>

<pre><code>ArrayList&lt;JLabel&gt; label1 = new ArrayList&lt;JLabel&gt;();
ArrayList&lt;JLabel&gt; label2 = new ArrayList&lt;JLabel&gt;();
</code></pre>

<p><code>label1</code> contains names (like ""John"" or ""car"") and <code>label2</code> contain ratings (like ""8.5"" or ""10.0""). I wanna sort both lists by rating.</p>

<p>I've used <code>Collections.sort(label2, new Sort());</code> to sort <code>label2</code>, but I have no idea how to sort <code>label1</code> in exaclty the same way (using <code>label2</code> objects). Here is my <code>Comparator</code> class:</p>

<pre><code>class Sort implements Comparator&lt;JLabel&gt;{
    public int compare(JLabel o1, JLabel o2) {
        Double a = Double.parseDouble(o1.getText());
        Double b = Double.parseDouble(o2.getText());
        return  b.compareTo(a);
    }
}
</code></pre>

<p>Any ideas?</p>","<p>Let's solve this using a <code>Map</code>. We'll first define a comparator to sort descending by value, like so:</p>

<pre><code>class NumericComparator extends Comparator {
    Map map;
    public NumericComparator(Map map) {
        this.map = map;
    }

    public int compare(Object o1, Object o2) {
        return ((Integer) map.get(o2)).compareTo((Integer) map.get(o1));
    }
}
</code></pre>

<p>We'll define the name as the key, and the rating as the value. Like so:</p>

<pre><code>Map&lt;String, Double&gt; carMap = new HashMap&lt;&gt;();
//we can populate the map like so:
carMap.put(""John"", 10d); //works nicely in loops
</code></pre>

<p>Then we take that unsorted map, and insert all of it's values into a <code>TreeMap</code>, that implements the <code>NumericComparator</code> we defined earlier. </p>

<pre><code>NumericComparator nc = new NumericComparator(carMap);
Map&lt;String, Double&gt; sortedMap = new TreeMap(nc);
sortedMap.putAll(carMap);
</code></pre>",33577636,0,java|sorting|arraylist
How to sort ArrayList according to another ArrayList?,"<p>I've got two <code>ArrayList&lt;JLabel&gt;</code>:</p>

<pre><code>ArrayList&lt;JLabel&gt; label1 = new ArrayList&lt;JLabel&gt;();
ArrayList&lt;JLabel&gt; label2 = new ArrayList&lt;JLabel&gt;();
</code></pre>

<p><code>label1</code> contains names (like ""John"" or ""car"") and <code>label2</code> contain ratings (like ""8.5"" or ""10.0""). I wanna sort both lists by rating.</p>

<p>I've used <code>Collections.sort(label2, new Sort());</code> to sort <code>label2</code>, but I have no idea how to sort <code>label1</code> in exaclty the same way (using <code>label2</code> objects). Here is my <code>Comparator</code> class:</p>

<pre><code>class Sort implements Comparator&lt;JLabel&gt;{
    public int compare(JLabel o1, JLabel o2) {
        Double a = Double.parseDouble(o1.getText());
        Double b = Double.parseDouble(o2.getText());
        return  b.compareTo(a);
    }
}
</code></pre>

<p>Any ideas?</p>","<p>First, please program to the <code>List</code> interface. Next, I'm assuming you can use apache libraries, there is <a href=""http://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/tuple/Pair.html"" rel=""nofollow noreferrer""><code>Pair&lt;L, R&gt;</code></a> in <a href=""https://commons.apache.org/proper/commons-lang/"" rel=""nofollow noreferrer"">apache commons-lang</a> (or you could implement your own tuple class; or use another like <a href=""https://stackoverflow.com/a/2671052/2970947"">this one</a>). Regardless, you'll need to modify your <code>Comparator</code> to operate on the right-hand side (and I personally like to use the left-hand side to break ties). Finally, if you want to use <code>label1</code> and <code>label2</code> you'll need to copy the values back (after sorting). Something like,</p>

<pre><code>List&lt;JLabel&gt; label1 = new ArrayList&lt;&gt;();
List&lt;JLabel&gt; label2 = new ArrayList&lt;&gt;();
// ...
List&lt;Pair&lt;JLabel, JLabel&gt;&gt; pairs = new ArrayList&lt;&gt;();
int len = label1.size();
if (len == label2.size()) {
    for (int i = 0; i &lt; len; i++) {
        pairs.add(Pair.of(label1.get(i), label2.get(i)));
    }
    Collections.sort(pairs, new Comparator&lt;Pair&lt;JLabel, JLabel&gt;&gt;() {
        @Override
        public int compare(Pair&lt;JLabel, JLabel&gt; o1,
                Pair&lt;JLabel, JLabel&gt; o2) {
            double a = Double.parseDouble(o1.getRight().getText());
            double b = Double.parseDouble(o2.getRight().getText());
            int ret = Double.compare(a, b);
            if (ret != 0) {
                return ret;
            } // if ret is 0, it's a tie.
            return o1.getLeft().getText()
                    .compareTo(o2.getLeft().getText());
        }
    });
    // ... only if you need to use label1 and label2 after the sort.
    for (int i = 0; i &lt; len; i++) {
        label1.set(i, pairs.get(i).getLeft());
        label2.set(i, pairs.get(i).getRight());
    }
}
</code></pre>",33577636,0,java|sorting|arraylist
How to sort ArrayList according to another ArrayList?,"<p>I've got two <code>ArrayList&lt;JLabel&gt;</code>:</p>

<pre><code>ArrayList&lt;JLabel&gt; label1 = new ArrayList&lt;JLabel&gt;();
ArrayList&lt;JLabel&gt; label2 = new ArrayList&lt;JLabel&gt;();
</code></pre>

<p><code>label1</code> contains names (like ""John"" or ""car"") and <code>label2</code> contain ratings (like ""8.5"" or ""10.0""). I wanna sort both lists by rating.</p>

<p>I've used <code>Collections.sort(label2, new Sort());</code> to sort <code>label2</code>, but I have no idea how to sort <code>label1</code> in exaclty the same way (using <code>label2</code> objects). Here is my <code>Comparator</code> class:</p>

<pre><code>class Sort implements Comparator&lt;JLabel&gt;{
    public int compare(JLabel o1, JLabel o2) {
        Double a = Double.parseDouble(o1.getText());
        Double b = Double.parseDouble(o2.getText());
        return  b.compareTo(a);
    }
}
</code></pre>

<p>Any ideas?</p>","<p>Given that you have no relationship defined between the two lists I think you should consider wrapping the two values up in a class:</p>

<pre><code>class Foo {

   private String name;
   private double rating;

   public Foo(String name, double rating){
       this.name = name;
       this.rating = rating;
   }

   // getters &amp; setters
}
</code></pre>

<p>You can then have <code>List&lt;Foo&gt;</code> and sort the list based on the value of rating.</p>

<p>In Java 8 this would be as simple as calling the <code>sort()</code> method, which is now provided in <code>List</code>, with a lambda expression passed in.</p>",33577636,2,java|sorting|arraylist
How to sort ArrayList according to another ArrayList?,"<p>I've got two <code>ArrayList&lt;JLabel&gt;</code>:</p>

<pre><code>ArrayList&lt;JLabel&gt; label1 = new ArrayList&lt;JLabel&gt;();
ArrayList&lt;JLabel&gt; label2 = new ArrayList&lt;JLabel&gt;();
</code></pre>

<p><code>label1</code> contains names (like ""John"" or ""car"") and <code>label2</code> contain ratings (like ""8.5"" or ""10.0""). I wanna sort both lists by rating.</p>

<p>I've used <code>Collections.sort(label2, new Sort());</code> to sort <code>label2</code>, but I have no idea how to sort <code>label1</code> in exaclty the same way (using <code>label2</code> objects). Here is my <code>Comparator</code> class:</p>

<pre><code>class Sort implements Comparator&lt;JLabel&gt;{
    public int compare(JLabel o1, JLabel o2) {
        Double a = Double.parseDouble(o1.getText());
        Double b = Double.parseDouble(o2.getText());
        return  b.compareTo(a);
    }
}
</code></pre>

<p>Any ideas?</p>","<p>Good question -- and also a hassle for me when sorting player order by dice-throw in a board game app.</p>

<p>The previous answer of binding the two lists within a new gross object or in a map (when all the strings are unique) is fine.</p>

<p>But if you do want something simpler then here is this.<br>
I was originally doing this without referencing a deep copy of the original comparison list and it was getting some of the sorting right and some odd entries mixed in . . . 
Eventually I saw the light and made a deep copy (label11) of the original list.
Also ensure to put the sorting code into a private method so as to enable access to the two lists, label11 &amp; label2, by the sort Comparator's overriding compare(..) method.</p>

<pre><code> . . . .
 . . . .

ArrayList&lt;JLabel&gt; label1 = new ArrayList&lt;JLabel&gt;(); // String list
ArrayList&lt;JLabel&gt; label2 = new ArrayList&lt;JLabel&gt;(); // Double list 
System.out.println(""Original String list : "" + label1); // Check original list
sortByValue(label1, label2);  // Sort label1 by label2 order descending
System.out.println(""Sorted String list: "" + label1);    // Check sorted list

. . . . 
. . . . 

/** Private static method to facilitate access to list being sorted and 
  * the list used as a sort criterion by the code in the sort Comparator's 
  * overriding compare(..) method. */
private static void sortByValue(ArrayList&lt;JLabel&gt; label1,
                                ArrayList&lt;JLabel&gt; label2)
{
   ArrayList&lt;JLabel&gt; label11 = 
     new ArrayList&lt;JLabel&gt;(label1);     // Deep copy original string list
   Collections.sort(list1, new Comparator&lt;JLabel&gt;()
   {
     @Override
     public int compare(JLabel x, JLabel y)
     {
      return                            // Sort by descending label2 values
       (Double.parseDouble(label2.get(label11.indexOf(y)).getText())
        -Double.parseDouble(label2.get(label11.indexOf(x)).getText()))
        .intValue();
     }
   });
}
</code></pre>",33577636,0,java|sorting|arraylist
How to write array to OutputStream in Java?,"<p>I want to send more than one random value though <code>Socket</code>. I think array is the best way to send them. But I don't know how to write an array to Socket <code>OutputStream</code>?</p>

<p>My Java class:</p>

<p>import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.io.*;
import java.util.Random;</p>

<pre><code>public class NodeCommunicator {

    public static void main(String[] args) {
        try {
            Socket nodejs = new Socket(""localhost"", 8181);

            Random randomGenerator = new Random();
            for (int idx = 1; idx &lt;= 1000; ++idx){
                Thread.sleep(500);
                int randomInt = randomGenerator.nextInt(35);
                sendMessage(nodejs, randomInt + "" "");
                System.out.println(randomInt);
            }

            while(true){
                Thread.sleep(1000);
            }
        } catch (Exception e) {
            System.out.println(""Connection terminated..Closing Java Client"");
            System.out.println(""Error :- ""+e);
        }
    }

    public static void sendMessage(Socket s, String message) throws IOException {
        s.getOutputStream().write(message.getBytes(""UTF-8""));
        s.getOutputStream().flush();
    }

}
</code></pre>","<p>if you want to send more than one random value to the socket, choose a simple format and make both parties agree to it (sender and reciever), for example you can simply choose a separator like <code>;</code> and create a string with all values with that separator and then send</p>",13984142,0,java|sockets|outputstream
How to write array to OutputStream in Java?,"<p>I want to send more than one random value though <code>Socket</code>. I think array is the best way to send them. But I don't know how to write an array to Socket <code>OutputStream</code>?</p>

<p>My Java class:</p>

<p>import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.io.*;
import java.util.Random;</p>

<pre><code>public class NodeCommunicator {

    public static void main(String[] args) {
        try {
            Socket nodejs = new Socket(""localhost"", 8181);

            Random randomGenerator = new Random();
            for (int idx = 1; idx &lt;= 1000; ++idx){
                Thread.sleep(500);
                int randomInt = randomGenerator.nextInt(35);
                sendMessage(nodejs, randomInt + "" "");
                System.out.println(randomInt);
            }

            while(true){
                Thread.sleep(1000);
            }
        } catch (Exception e) {
            System.out.println(""Connection terminated..Closing Java Client"");
            System.out.println(""Error :- ""+e);
        }
    }

    public static void sendMessage(Socket s, String message) throws IOException {
        s.getOutputStream().write(message.getBytes(""UTF-8""));
        s.getOutputStream().flush();
    }

}
</code></pre>","<p>Well, a stream is a stream of bytes, so you must encode the data into a sequence of bytes, and decode it on the receiving side. How to write the data depends on how you want to encode it. </p>

<p>As numbers from 0 to 34 fit in a single byte, this can be as easy as:</p>

<pre><code>outputStream.write(randomNumber); 
</code></pre>

<p>and on the other side:</p>

<pre><code>int randomNumber = inputStream.read();
</code></pre>

<p>Of course, flushing the stream after every byte is not very efficient (as it'll generate a network packet for every byte, and each network packet contains dozens of bytes of header and routing information ...). Should performance matter, you'll probably want to use a BufferedOutputStream, too.</p>",13984142,1,java|sockets|outputstream
How to write array to OutputStream in Java?,"<p>I want to send more than one random value though <code>Socket</code>. I think array is the best way to send them. But I don't know how to write an array to Socket <code>OutputStream</code>?</p>

<p>My Java class:</p>

<p>import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.io.*;
import java.util.Random;</p>

<pre><code>public class NodeCommunicator {

    public static void main(String[] args) {
        try {
            Socket nodejs = new Socket(""localhost"", 8181);

            Random randomGenerator = new Random();
            for (int idx = 1; idx &lt;= 1000; ++idx){
                Thread.sleep(500);
                int randomInt = randomGenerator.nextInt(35);
                sendMessage(nodejs, randomInt + "" "");
                System.out.println(randomInt);
            }

            while(true){
                Thread.sleep(1000);
            }
        } catch (Exception e) {
            System.out.println(""Connection terminated..Closing Java Client"");
            System.out.println(""Error :- ""+e);
        }
    }

    public static void sendMessage(Socket s, String message) throws IOException {
        s.getOutputStream().write(message.getBytes(""UTF-8""));
        s.getOutputStream().flush();
    }

}
</code></pre>","<p>So you can compare the alternative formats I have written a template which allows you to use any format your wish, or compare the alternatives.</p>

<pre><code>abstract class DataSocket implements Closeable {
    private final Socket socket;
    protected final DataOutputStream out;
    protected final DataInputStream in;

    DataSocket(Socket socket) throws IOException {
        this.socket = socket;
        out = new DataOutputStream(new BufferedOutputStream(socket.getOutputStream()));
        in = new DataInputStream(new BufferedInputStream(socket.getInputStream()));
    }

    public void writeInts(int[] ints) throws IOException {
        writeInt(ints.length);
        for (int i : ints)
            writeInt(i);
        endOfBlock();
    }

    protected abstract void writeInt(int i) throws IOException;

    protected abstract void endOfBlock() throws IOException;

    public int[] readInts() throws IOException {
        nextBlock();
        int len = readInt();
        int[] ret = new int[len];
        for (int i = 0; i &lt; len; i++)
            ret[i] = readInt();
        return ret;
    }

    protected abstract void nextBlock() throws IOException;

    protected abstract int readInt() throws IOException;

    public void close() throws IOException {
        out.close();
        in.close();
        socket.close();
    }
}
</code></pre>

<p>binary format, 4-byte ints</p>

<pre><code>class BinaryDataSocket extends DataSocket {
    BinaryDataSocket(Socket socket) throws IOException {
        super(socket);
    }

    @Override
    protected void writeInt(int i) throws IOException {
        out.writeInt(i);
    }

    @Override
    protected void endOfBlock() throws IOException {
        out.flush();
    }

    @Override
    protected void nextBlock() {
        // nothing
    }

    @Override
    protected int readInt() throws IOException {
        return in.readInt();
    }
}
</code></pre>

<p>stop bit encoded binary with one byte per 7 bits.</p>

<pre><code>class CompactBinaryDataSocket extends DataSocket {
    CompactBinaryDataSocket(Socket socket) throws IOException {
        super(socket);
    }

    @Override
    protected void writeInt(int i) throws IOException {
        // uses one byte per 7 bit set.
        long l = i &amp; 0xFFFFFFFFL;
        while (l &gt;= 0x80) {
            out.write((int) (l | 0x80));
            l &gt;&gt;&gt;= 7;
        }
        out.write((int) l);
    }

    @Override
    protected void endOfBlock() throws IOException {
        out.flush();
    }

    @Override
    protected void nextBlock() {
        // nothing
    }

    @Override
    protected int readInt() throws IOException {
        long l = 0;
        int b, count = 0;
        while ((b = in.read()) &gt;= 0x80) {
            l |= (b &amp; 0x7f) &lt;&lt; 7 * count++;
        }
        if (b &lt; 0) throw new EOFException();
        l |= b &lt;&lt; 7 * count;
        return (int) l;
    }
}
</code></pre>

<p>text encoded with a new line at the end.</p>

<pre><code>class TextDataSocket extends DataSocket {
    TextDataSocket(Socket socket) throws IOException {
        super(socket);
    }

    private boolean outBlock = false;

    @Override
    protected void writeInt(int i) throws IOException {
        if (outBlock) out.write(' ');
        out.write(Integer.toString(i).getBytes());
        outBlock = true;
    }

    @Override
    protected void endOfBlock() throws IOException {
        out.write('\n');
        out.flush();
        outBlock = false;
    }

    private Scanner inLine = null;

    @Override
    protected void nextBlock() throws IOException {
        inLine = new Scanner(in.readLine());
    }

    @Override
    protected int readInt() throws IOException {
        return inLine.nextInt();
    }
}
</code></pre>",13984142,1,java|sockets|outputstream
How to write array to OutputStream in Java?,"<p>I want to send more than one random value though <code>Socket</code>. I think array is the best way to send them. But I don't know how to write an array to Socket <code>OutputStream</code>?</p>

<p>My Java class:</p>

<p>import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.io.*;
import java.util.Random;</p>

<pre><code>public class NodeCommunicator {

    public static void main(String[] args) {
        try {
            Socket nodejs = new Socket(""localhost"", 8181);

            Random randomGenerator = new Random();
            for (int idx = 1; idx &lt;= 1000; ++idx){
                Thread.sleep(500);
                int randomInt = randomGenerator.nextInt(35);
                sendMessage(nodejs, randomInt + "" "");
                System.out.println(randomInt);
            }

            while(true){
                Thread.sleep(1000);
            }
        } catch (Exception e) {
            System.out.println(""Connection terminated..Closing Java Client"");
            System.out.println(""Error :- ""+e);
        }
    }

    public static void sendMessage(Socket s, String message) throws IOException {
        s.getOutputStream().write(message.getBytes(""UTF-8""));
        s.getOutputStream().flush();
    }

}
</code></pre>","<p>Use java.io.DataOutputStream / DataInputStream pair, they know how to read ints. Send info as a packet of length +  random numbers.</p>

<p>sender</p>

<pre><code>Socket sock = new Socket(""localhost"", 8181);
DataOutputStream out = new DataOutputStream(sock.getOutputStream());
out.writeInt(len);
for(int i = 0; i &lt; len; i++) {
      out.writeInt(randomGenerator.nextInt(35))
...
</code></pre>

<p>receiver</p>

<pre><code> DataInputStream in = new DataInputStream(sock.getInputStream());
 int len = in.readInt();
 for(int i = 0; i &lt; len; i++) {
      int next = in.readInt();
 ...
</code></pre>",13984142,8,java|sockets|outputstream
How to write array to OutputStream in Java?,"<p>I want to send more than one random value though <code>Socket</code>. I think array is the best way to send them. But I don't know how to write an array to Socket <code>OutputStream</code>?</p>

<p>My Java class:</p>

<p>import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.io.*;
import java.util.Random;</p>

<pre><code>public class NodeCommunicator {

    public static void main(String[] args) {
        try {
            Socket nodejs = new Socket(""localhost"", 8181);

            Random randomGenerator = new Random();
            for (int idx = 1; idx &lt;= 1000; ++idx){
                Thread.sleep(500);
                int randomInt = randomGenerator.nextInt(35);
                sendMessage(nodejs, randomInt + "" "");
                System.out.println(randomInt);
            }

            while(true){
                Thread.sleep(1000);
            }
        } catch (Exception e) {
            System.out.println(""Connection terminated..Closing Java Client"");
            System.out.println(""Error :- ""+e);
        }
    }

    public static void sendMessage(Socket s, String message) throws IOException {
        s.getOutputStream().write(message.getBytes(""UTF-8""));
        s.getOutputStream().flush();
    }

}
</code></pre>","<p>I would advice to simply concatenate the <code>int</code> values in a string using some delimiter e.g. <code>@@</code>, then transmit the final concatenated string at once. On the receiving side, just split the string using same delimiter to get the <code>int[]</code> back e.g.:</p>

<pre><code>    Random randomGenerator = new Random();
    StringBuilder numToSend = new StringBuilder("""");
    numToSend.append(randomGenerator.nextInt(35));

    for (int idx = 2; idx &lt;= 1000; ++idx){
        Thread.sleep(500);
        numToSend.append(""@@"").append(randomGenerator.nextInt(35));
    }
    String numsString = numToSend.toString();
    System.out.println(numsString);
    sendMessage(nodejs, numsString);
</code></pre>

<p>On the receiving side, get your string and split as:</p>

<pre><code>   Socket remotejs = new Socket(""remotehost"", 8181);
   BufferedReader in = new BufferedReader(
                               new InputStreamReader(remotejs.getInputStream()));
   String receivedNumString = in.readLine();
   String[] numstrings = receivedNumString.split(""@@"");
   int[] nums = new int[numstrings.length];
   int indx = 0;
   for(String numStr: numstrings){
     nums[indx++] = Integer.parseInt(numStr);
   }
</code></pre>",13984142,2,java|sockets|outputstream
How to write array to OutputStream in Java?,"<p>I want to send more than one random value though <code>Socket</code>. I think array is the best way to send them. But I don't know how to write an array to Socket <code>OutputStream</code>?</p>

<p>My Java class:</p>

<p>import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.io.*;
import java.util.Random;</p>

<pre><code>public class NodeCommunicator {

    public static void main(String[] args) {
        try {
            Socket nodejs = new Socket(""localhost"", 8181);

            Random randomGenerator = new Random();
            for (int idx = 1; idx &lt;= 1000; ++idx){
                Thread.sleep(500);
                int randomInt = randomGenerator.nextInt(35);
                sendMessage(nodejs, randomInt + "" "");
                System.out.println(randomInt);
            }

            while(true){
                Thread.sleep(1000);
            }
        } catch (Exception e) {
            System.out.println(""Connection terminated..Closing Java Client"");
            System.out.println(""Error :- ""+e);
        }
    }

    public static void sendMessage(Socket s, String message) throws IOException {
        s.getOutputStream().write(message.getBytes(""UTF-8""));
        s.getOutputStream().flush();
    }

}
</code></pre>","<p>Java arrays are actually <code>Object</code>s and moreover they implement the <code>Serializable</code> interface. So, you can serialize your array, get the bytes and send those through the socket. This should do it: </p>

<pre class=""lang-java prettyprint-override""><code>public static void sendMessage(Socket s, int[] myMessageArray)
   throws IOException {
  ByteArrayOutputStream bs = new ByteArrayOutputStream();
  ObjectOutputStream os = new ObjectOutputStream(bs);
  os.writeObject(myMessageArray);
  byte[] messageArrayBytes = bs.toByteArray();
  s.getOutputStream().write(messageArrayBytes);
  s.getOutputStream().flush();
}
</code></pre>

<p>What's really neat about this is that it works not only for <code>int[]</code> but for any <code>Serializable</code> object.</p>

<p><strong>Edit:</strong>
Thinking about it again, this is even simpler:</p>

<p><em>sender</em>:</p>

<pre><code>public static void sendMessage(Socket s, int[] myMessageArray)
   throws IOException {
  OutputStream os = s.getOutputStream();  
  ObjectOutputStream oos = new ObjectOutputStream(os);  
  oos.writeObject(myMessageArray); 
}
</code></pre>

<p><em>receiver</em>:</p>

<pre><code>public static int[] getMessage(Socket s)
   throws IOException {
  InputStream is = s.getInputStream();  
  ObjectInputStream ois = new ObjectInputStream(is);  
  int[] myMessageArray = (int[])ois.readObject(); 
  return myMessageArray;
}
</code></pre>

<p>I'm leaving my first answer also as(it also works and) it's useful for writing objects to UDP <code>DatagramSockets</code> and <code>DatagramPackets</code> where there is no stream.</p>",13984142,4,java|sockets|outputstream
How to write array to OutputStream in Java?,"<p>I want to send more than one random value though <code>Socket</code>. I think array is the best way to send them. But I don't know how to write an array to Socket <code>OutputStream</code>?</p>

<p>My Java class:</p>

<p>import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.Socket;
import java.io.*;
import java.util.Random;</p>

<pre><code>public class NodeCommunicator {

    public static void main(String[] args) {
        try {
            Socket nodejs = new Socket(""localhost"", 8181);

            Random randomGenerator = new Random();
            for (int idx = 1; idx &lt;= 1000; ++idx){
                Thread.sleep(500);
                int randomInt = randomGenerator.nextInt(35);
                sendMessage(nodejs, randomInt + "" "");
                System.out.println(randomInt);
            }

            while(true){
                Thread.sleep(1000);
            }
        } catch (Exception e) {
            System.out.println(""Connection terminated..Closing Java Client"");
            System.out.println(""Error :- ""+e);
        }
    }

    public static void sendMessage(Socket s, String message) throws IOException {
        s.getOutputStream().write(message.getBytes(""UTF-8""));
        s.getOutputStream().flush();
    }

}
</code></pre>","<p><a href=""http://examples.javacodegeeks.com/android/core/socket-core/android-socket-example/"" rel=""nofollow"" title=""Android Socket Example"">Android Socket SERVER Example</a> modified to receive arrays of integers instead of strings:</p>

<pre><code>...
class CommunicationThread implements Runnable {

    private ObjectInputStream input;

    public CommunicationThread(Socket clientSocket) {

        try {

            this.input = new ObjectInputStream(clientSocket.getInputStream());

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void run() {

        while (!Thread.currentThread().isInterrupted()) {

            try {

                int[] myMessageArray = (int[]) input.readObject();

                String read = null;
                read = String.format(""%05X"", myMessageArray[0] &amp; 0x0FFFFF);
                int i = 1;
                do {
                    read = read + "", "" + String.format(""%05X"", myMessageArray[i] &amp; 0x0FFFFF);
                    i++;
                } while (i &lt; myMessageArray.length);
                read = read + "" ("" + myMessageArray.length + "" bytes)"";

                updateConversationHandler.post(new updateUIThread(read));

            } catch (IOException e) {
                e.printStackTrace();
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
            }
        }
    }
}
...
</code></pre>",13984142,0,java|sockets|outputstream
How to find max value in a binary tree,"<p>I have to complete the method <strong>maxElem(Node node)</strong> in such a way that the method <strong>maxElem()</strong> returns the maximum value contained in a binary tree. </p>

<p>How can I do that? I do not know how to do that..</p>

<pre><code>public class BinaryTree {

    protected class Node {
        protected Integer element;
        protected Node left;
        protected Node right;

        Node(int element) {
            this.element = element;
            left = right = null;
        }

        Node(int element, Node left, Node right) {
            this.element = element;
            this.left = left;
            this.right = right;
        }

    } //end Node class

    public class NodeReference {
        private Node node;

        private NodeReference(Node node) {
            this.node = node;
        }

        public int getElement() {
            return node.element;
        }

        public void setElement(int e) {
            node.element = e;
        }
    }

    protected Node root;

    public BinaryTree() {
        root = null;
    }

    private class BoolNode {

        boolean found; 
        Node node;

        BoolNode(boolean found, Node node) {
            this.found = found;
            this.node = node;
        }
    }

    public int maxElem() {
        if(root == null) 
            throw new IllegalStateException(""Empty tree."");
        return maxElem(root);
    }


    private static int max3(int x, int y, int z) {
        return max(x, max(y, z));
    }

    private int maxElem(Node node) {
        //...
    }

}
</code></pre>

<p>Thanks a lot!</p>","<p><strong>1</strong>)Using <strong>Recursion</strong>:</p>

<p><strong>Note</strong>:You need the add <code>getElement()</code>, <code>getRight()</code>, <code>getLeft()</code> methods in your <em>Node</em> class so that the below code could work.</p>

<pre><code>public int findMaxInTree(Node root) {
        int max = Integer.MIN_VALUE;     //set a default max value
        if (root == null)
            return max;                 //if root is null
        else {
            int left_max = findMaxInTree(root.getLeft());           //get left side max
            int right_max = findMaxInTree(root.getRight());         //get right side max
            if (left_max &gt; right_max)                               //if left&gt;right
                max = left_max;                                     //set max=left
            else
                max=right_max;                                      //else set max=right

            if (root.getElement() &gt; max)                           //if root is greater than max of left or right
                max = root.getElement();                              //set max=root

        }
        return max;                                                //return max
    }
</code></pre>

<p><strong>2</strong>)You can use the <em>concept</em> of <strong>Breadth First Traversal</strong> to find the max.</p>

<pre><code>public void findMax(Node root) {
            if (root == null)
                System.out.println(""empty tree"");
            else {
                Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();  //make a queue
                Node max = root;                              //suppose max is root
                queue.add(root);                              //add root to queue
                while (queue.size() != 0) {                  //while size of queue is not empty  
                    Node temp = queue.remove();              //remove an item from queue
                    if (temp.getElement() &gt; max.getElement())    //if removed item is greater than max
                        max = temp;                             //set new max
                    if (temp.getLeft() != null)                                  
                        queue.add(temp.getLeft());             //traverse left
                    if (temp.getRight() != null)
                        queue.add(temp.getRight());            //traverse right
                }
                System.out.println(max.getElement());       //in the end ,print the max
            }
        }
</code></pre>",23173932,1,java|algorithm|binary-tree
How to find max value in a binary tree,"<p>I have to complete the method <strong>maxElem(Node node)</strong> in such a way that the method <strong>maxElem()</strong> returns the maximum value contained in a binary tree. </p>

<p>How can I do that? I do not know how to do that..</p>

<pre><code>public class BinaryTree {

    protected class Node {
        protected Integer element;
        protected Node left;
        protected Node right;

        Node(int element) {
            this.element = element;
            left = right = null;
        }

        Node(int element, Node left, Node right) {
            this.element = element;
            this.left = left;
            this.right = right;
        }

    } //end Node class

    public class NodeReference {
        private Node node;

        private NodeReference(Node node) {
            this.node = node;
        }

        public int getElement() {
            return node.element;
        }

        public void setElement(int e) {
            node.element = e;
        }
    }

    protected Node root;

    public BinaryTree() {
        root = null;
    }

    private class BoolNode {

        boolean found; 
        Node node;

        BoolNode(boolean found, Node node) {
            this.found = found;
            this.node = node;
        }
    }

    public int maxElem() {
        if(root == null) 
            throw new IllegalStateException(""Empty tree."");
        return maxElem(root);
    }


    private static int max3(int x, int y, int z) {
        return max(x, max(y, z));
    }

    private int maxElem(Node node) {
        //...
    }

}
</code></pre>

<p>Thanks a lot!</p>","<p><code>public static void maxElement(Node node, int max){
            static int MaxTemp;
            if(node==null)
                return;
            if(node.getData()&gt;min)
                MaxTemp=node.getData();
            if(node.getLeft()!=null &amp;&amp; node.getLeft().getData()&gt;max)
                MaxTemp=node.getLeft().getData();
            if(node.getRight()!=null &amp;&amp; node.getRight().getData()&gt;max)
                MaxTemp=node.getRight().getData();
            maxElement(node.getLeft(), MaxTemp);
            maxElement(node.getRight(), MaxTemp);
        }</code></p>",23173932,0,java|algorithm|binary-tree
How to find max value in a binary tree,"<p>I have to complete the method <strong>maxElem(Node node)</strong> in such a way that the method <strong>maxElem()</strong> returns the maximum value contained in a binary tree. </p>

<p>How can I do that? I do not know how to do that..</p>

<pre><code>public class BinaryTree {

    protected class Node {
        protected Integer element;
        protected Node left;
        protected Node right;

        Node(int element) {
            this.element = element;
            left = right = null;
        }

        Node(int element, Node left, Node right) {
            this.element = element;
            this.left = left;
            this.right = right;
        }

    } //end Node class

    public class NodeReference {
        private Node node;

        private NodeReference(Node node) {
            this.node = node;
        }

        public int getElement() {
            return node.element;
        }

        public void setElement(int e) {
            node.element = e;
        }
    }

    protected Node root;

    public BinaryTree() {
        root = null;
    }

    private class BoolNode {

        boolean found; 
        Node node;

        BoolNode(boolean found, Node node) {
            this.found = found;
            this.node = node;
        }
    }

    public int maxElem() {
        if(root == null) 
            throw new IllegalStateException(""Empty tree."");
        return maxElem(root);
    }


    private static int max3(int x, int y, int z) {
        return max(x, max(y, z));
    }

    private int maxElem(Node node) {
        //...
    }

}
</code></pre>

<p>Thanks a lot!</p>","<p>Try:</p>

<pre><code>private int maxElem(Node node) {
    int max = node.element;
    if(node.left != null) {
        max = Math.max(max, maxElem(node.left));
    }
    if(node.right != null) {
        max = Math.max(max, maxElem(node.right));
    }
    return max;
}
</code></pre>",23173932,11,java|algorithm|binary-tree
How to find max value in a binary tree,"<p>I have to complete the method <strong>maxElem(Node node)</strong> in such a way that the method <strong>maxElem()</strong> returns the maximum value contained in a binary tree. </p>

<p>How can I do that? I do not know how to do that..</p>

<pre><code>public class BinaryTree {

    protected class Node {
        protected Integer element;
        protected Node left;
        protected Node right;

        Node(int element) {
            this.element = element;
            left = right = null;
        }

        Node(int element, Node left, Node right) {
            this.element = element;
            this.left = left;
            this.right = right;
        }

    } //end Node class

    public class NodeReference {
        private Node node;

        private NodeReference(Node node) {
            this.node = node;
        }

        public int getElement() {
            return node.element;
        }

        public void setElement(int e) {
            node.element = e;
        }
    }

    protected Node root;

    public BinaryTree() {
        root = null;
    }

    private class BoolNode {

        boolean found; 
        Node node;

        BoolNode(boolean found, Node node) {
            this.found = found;
            this.node = node;
        }
    }

    public int maxElem() {
        if(root == null) 
            throw new IllegalStateException(""Empty tree."");
        return maxElem(root);
    }


    private static int max3(int x, int y, int z) {
        return max(x, max(y, z));
    }

    private int maxElem(Node node) {
        //...
    }

}
</code></pre>

<p>Thanks a lot!</p>","<pre><code>    public static int maxInTree(BinTreeNode&lt;int&gt; t)
    {
        int max = t.GetInfo();
        if (t != null)
        {
            if (t.GetLeft() != null)
                max = Math.Max(max, maxInTree(t.GetLeft()));
            if (t.GetRight() != null)
                max = Math.Max(max, maxInTree(t.GetRight()));
        }
        return max;
    }
</code></pre>",23173932,0,java|algorithm|binary-tree
How to find max value in a binary tree,"<p>I have to complete the method <strong>maxElem(Node node)</strong> in such a way that the method <strong>maxElem()</strong> returns the maximum value contained in a binary tree. </p>

<p>How can I do that? I do not know how to do that..</p>

<pre><code>public class BinaryTree {

    protected class Node {
        protected Integer element;
        protected Node left;
        protected Node right;

        Node(int element) {
            this.element = element;
            left = right = null;
        }

        Node(int element, Node left, Node right) {
            this.element = element;
            this.left = left;
            this.right = right;
        }

    } //end Node class

    public class NodeReference {
        private Node node;

        private NodeReference(Node node) {
            this.node = node;
        }

        public int getElement() {
            return node.element;
        }

        public void setElement(int e) {
            node.element = e;
        }
    }

    protected Node root;

    public BinaryTree() {
        root = null;
    }

    private class BoolNode {

        boolean found; 
        Node node;

        BoolNode(boolean found, Node node) {
            this.found = found;
            this.node = node;
        }
    }

    public int maxElem() {
        if(root == null) 
            throw new IllegalStateException(""Empty tree."");
        return maxElem(root);
    }


    private static int max3(int x, int y, int z) {
        return max(x, max(y, z));
    }

    private int maxElem(Node node) {
        //...
    }

}
</code></pre>

<p>Thanks a lot!</p>","<p>Here is one way you could get the maximum value of a tree.</p>

<pre class=""lang-java prettyprint-override""><code>public static int maxElem(Node node) {
    if (node == null) {
        return Integer.MIN_VALUE;
    }

    int max = Math.max(maxElem(node.left), maxElem(node.right));
    return max &gt; node.element ? max : node.element;
}
</code></pre>",23173932,1,java|algorithm|binary-tree
How to draw a tree representing a graph of connected nodes?,"<p>I want to display a tree in a Java GUI, but I dont know how. The tree represents a graph of connected nodes, like this:</p>

<p><img src=""https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/300px-Binary_tree.svg.png"" alt=""image""></p>

<p>I should say that I have my own tree class:</p>

<pre><code>public class BinaryTree  
{
private BinaryNode root;
public BinaryTree( )
{
    root = null;
}

public BinaryTree( Object rootItem )
{
    root = new BinaryNode( rootItem, null, null );
}

public BinaryTree( Object rootItem,BinaryNode a,BinaryNode b )
{
    root = new BinaryNode( rootItem, a, b );
}

public int leavesCount(){
    return BinaryNode.leavesCount(root);
}

public boolean equal(BinaryTree a,BinaryTree b){
    return BinaryNode.equal(a.root, b.root);

}

public void printPreOrder( )
{
    if( root != null )
        root.printPreOrder( );
}

public void printInOrder( )
{
    if( root != null )
       root.printInOrder( );
}

public void printPostOrder( )
{
    if( root != null )
       root.printPostOrder( );
}

public void makeEmpty( )
{
    root = null;
}


public boolean isEmpty( )
{
    return root == null;
}


public void merge( Object rootItem, BinaryTree t1, BinaryTree t2 ) throws MergeAbrot
{
    if( t1.root == t2.root &amp;&amp; t1.root != null )
    {
         throw new MergeAbrot(""MergeAbrot"");

    }

     root=new BinaryNode( rootItem, t1.root, t2.root );

    if( this != t1 )
        t1.root = null;
    if( this != t2 )
       t2.root = null;
}

public int size( )
{
    return BinaryNode.size( root );
}

public int height( )
{
    return BinaryNode.height( root );
}

}
</code></pre>

<p>I only want to draw the tree. How should I do?</p>","<p>The simplest way I can think of is to write a class that extends <code>JPanel</code> and override its <code>paintComponent()</code> method. In the paint method you can iterate through the tree and paint each node. Here is a short example:</p>

<pre><code>import java.awt.Graphics;
import javax.swing.JFrame;
import javax.swing.JPanel;

public class JPanelTest extends JPanel {

    @Override
    public void paintComponent(Graphics g) {
        // Draw Tree Here
        g.drawOval(5, 5, 25, 25);
    }

    public static void main(String[] args) {
        JFrame jFrame = new JFrame();
        jFrame.add(new JPanelTest());
        jFrame.setSize(500, 500);
        jFrame.setVisible(true);
    }

}
</code></pre>

<p>Take a stab at painting the tree, if you can't figure it out post what you've tried in your question.</p>",10126695,7,java|swing|swt|awt
How to draw a tree representing a graph of connected nodes?,"<p>I want to display a tree in a Java GUI, but I dont know how. The tree represents a graph of connected nodes, like this:</p>

<p><img src=""https://upload.wikimedia.org/wikipedia/commons/thumb/f/f7/Binary_tree.svg/300px-Binary_tree.svg.png"" alt=""image""></p>

<p>I should say that I have my own tree class:</p>

<pre><code>public class BinaryTree  
{
private BinaryNode root;
public BinaryTree( )
{
    root = null;
}

public BinaryTree( Object rootItem )
{
    root = new BinaryNode( rootItem, null, null );
}

public BinaryTree( Object rootItem,BinaryNode a,BinaryNode b )
{
    root = new BinaryNode( rootItem, a, b );
}

public int leavesCount(){
    return BinaryNode.leavesCount(root);
}

public boolean equal(BinaryTree a,BinaryTree b){
    return BinaryNode.equal(a.root, b.root);

}

public void printPreOrder( )
{
    if( root != null )
        root.printPreOrder( );
}

public void printInOrder( )
{
    if( root != null )
       root.printInOrder( );
}

public void printPostOrder( )
{
    if( root != null )
       root.printPostOrder( );
}

public void makeEmpty( )
{
    root = null;
}


public boolean isEmpty( )
{
    return root == null;
}


public void merge( Object rootItem, BinaryTree t1, BinaryTree t2 ) throws MergeAbrot
{
    if( t1.root == t2.root &amp;&amp; t1.root != null )
    {
         throw new MergeAbrot(""MergeAbrot"");

    }

     root=new BinaryNode( rootItem, t1.root, t2.root );

    if( this != t1 )
        t1.root = null;
    if( this != t2 )
       t2.root = null;
}

public int size( )
{
    return BinaryNode.size( root );
}

public int height( )
{
    return BinaryNode.height( root );
}

}
</code></pre>

<p>I only want to draw the tree. How should I do?</p>","<p>You might consider any of these:</p>

<ul>
<li><p><a href=""http://www.jhotdraw.org"" rel=""nofollow noreferrer"">JHotDraw</a>, cited <a href=""https://stackoverflow.com/a/13997870/230513"">here</a>, a meta-library for creating custom graph editors.</p></li>
<li><p><a href=""http://prefuse.org"" rel=""nofollow noreferrer"">Prefuse</a> visualization <a href=""https://stackoverflow.com/tags/prefuse/info"">library</a>, illustrated <a href=""https://stackoverflow.com/a/30395586/230513"">here</a> and <a href=""http://prefuse.org/gallery/"" rel=""nofollow noreferrer"">here</a>.</p></li>
<li><p><a href=""http://xmlgraphics.apache.org/batik/"" rel=""nofollow noreferrer"">Batik</a>, which implements SVG rendering.</p></li>
<li><p><a href=""http://www.jgraph.com/jgraph.html"" rel=""nofollow noreferrer"">JGraph</a> <a href=""http://www.diagram.ly/"" rel=""nofollow noreferrer"">demo</a> and <a href=""http://www.jgraph.com/doc/mxgraph/index_javavis.html"" rel=""nofollow noreferrer"">user manual</a>.</p></li>
<li><p><a href=""http://graphstream-project.org"" rel=""nofollow noreferrer"">GraphStream</a>, illustrated <a href=""https://stackoverflow.com/a/45055683/230513"">here</a>.</p></li>
<li><p><a href=""http://www.jfree.org/jfreechart/"" rel=""nofollow noreferrer"">JFreeChart</a> <a href=""http://www.jfree.org/jfreechart/api/javadoc/org/jfree/chart/renderer/xy/XYBubbleRenderer.html"" rel=""nofollow noreferrer""><code>XYBubbleRenderer</code></a></p></li>
<li><p>A <code>JTree</code>, suggested <a href=""https://stackoverflow.com/a/10126761/230513"">here</a>, with a custom <a href=""https://stackoverflow.com/a/4641530/230513""><code>TreeIcon</code></a>.</p></li>
<li><p>A <a href=""https://stackoverflow.com/a/10129112/230513"">custom renderer</a>, with <em>x</em> based on a fraction of tree breadth and <em>y</em> based on recursion level.</p></li>
<li><p>A simple graph editor such as <code>draw.GraphPanel</code>, illustrated <a href=""https://stackoverflow.com/a/11944233/230513"">here</a>.</p></li>
</ul>",10126695,13,java|swing|swt|awt
How to find if a string entered into scanner is in an array?,"<p>I have to: </p>

<p>Prompt the user for a string,
if the string entered is in the array ""names"", print out its index,
if not in names, print out ""NOT FOUND""</p>

<p>this is what I have:</p>

<p>This is for my programming final and i can't figure out how to do this because I missed 1 class...</p>

<pre><code>import java.util.Scanner;
public class Final1 {
   public static void main (String[] args) {
      int y;
      int x=0;

      Scanner s = new Scanner(System.in);

      String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

      System.out.print(""Enter String Name:"");
         y=s.nextInt();

            for (String a: names){
               if (a.equals(y)) 
                  System.out.println(y);   
            }

   }
}
</code></pre>","<p>Your <code>y</code> should be a <code>String</code> and you should input it with an <code>s.nextLine()</code>. Currently you are matching integers and strings. You could use the <code>indexOf</code></p>

<pre><code>int index = Arrays.asList(names).indexOf(s.nextLine());
return index &gt; -1 ? ""Not found"" : Integer.toString(index);
</code></pre>",50147769,1,java|arrays|string|java.util.scanner
How to find if a string entered into scanner is in an array?,"<p>I have to: </p>

<p>Prompt the user for a string,
if the string entered is in the array ""names"", print out its index,
if not in names, print out ""NOT FOUND""</p>

<p>this is what I have:</p>

<p>This is for my programming final and i can't figure out how to do this because I missed 1 class...</p>

<pre><code>import java.util.Scanner;
public class Final1 {
   public static void main (String[] args) {
      int y;
      int x=0;

      Scanner s = new Scanner(System.in);

      String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

      System.out.print(""Enter String Name:"");
         y=s.nextInt();

            for (String a: names){
               if (a.equals(y)) 
                  System.out.println(y);   
            }

   }
}
</code></pre>","<p>Use <code>Array.asList(yourArray).contains(yourValue)</code>:</p>

<pre><code>import java.util.*;

public class Final1 
{

public static void main (String[] args) 
{
     int y = 0;
     int x = 0;
     String name = """";

     Scanner s = new Scanner(System.in);

     String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

     System.out.print(""Enter String Name:"");

     name = s.nextLine();

     if(Arrays.asList(names).contains(name)) // Check this line
     {
        System.out.print(name);   
     }

   }
}
</code></pre>",50147769,3,java|arrays|string|java.util.scanner
How to find if a string entered into scanner is in an array?,"<p>I have to: </p>

<p>Prompt the user for a string,
if the string entered is in the array ""names"", print out its index,
if not in names, print out ""NOT FOUND""</p>

<p>this is what I have:</p>

<p>This is for my programming final and i can't figure out how to do this because I missed 1 class...</p>

<pre><code>import java.util.Scanner;
public class Final1 {
   public static void main (String[] args) {
      int y;
      int x=0;

      Scanner s = new Scanner(System.in);

      String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

      System.out.print(""Enter String Name:"");
         y=s.nextInt();

            for (String a: names){
               if (a.equals(y)) 
                  System.out.println(y);   
            }

   }
}
</code></pre>","<p>If you are trying to print the index of it instead of the actual name again you will have to modify it a bit.</p>

<pre><code>import java.util.*;

public class Final1 
{

  public static void main (String[] args) 
  {
     int y = 0;
     int x = 0;
     String name = """";
     boolean found = false;

     Scanner s = new Scanner(System.in);

     String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

     System.out.print(""Enter String Name:"");

     name = s.nextLine(); // get a string instead of an int

     // likely the way your professor would like you to do this
     // there are many ways, but this is the quickest while using a simple array
     // you could cast it to a list
     for(int i=0; i&lt;names.length; ++i){
       if(names[i].equals(name)){
         System.out.print(i);
         found = true;
       }
     }

     if(!found)
       System.out.println(""NOT FOUND"");
  }
}
</code></pre>

<p>Edit: You could also use the Arrays static class.</p>

<pre><code>int result = Arrays.binarySearch(names, name);
if(result &gt; 0)
  System.out.println(result);
else
  System.out.println(""NOT FOUND"");
</code></pre>",50147769,3,java|arrays|string|java.util.scanner
How to find if a string entered into scanner is in an array?,"<p>I have to: </p>

<p>Prompt the user for a string,
if the string entered is in the array ""names"", print out its index,
if not in names, print out ""NOT FOUND""</p>

<p>this is what I have:</p>

<p>This is for my programming final and i can't figure out how to do this because I missed 1 class...</p>

<pre><code>import java.util.Scanner;
public class Final1 {
   public static void main (String[] args) {
      int y;
      int x=0;

      Scanner s = new Scanner(System.in);

      String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

      System.out.print(""Enter String Name:"");
         y=s.nextInt();

            for (String a: names){
               if (a.equals(y)) 
                  System.out.println(y);   
            }

   }
}
</code></pre>","<p>You are comparing <code>int y</code> with scanned Integer. <code>y</code> should be a string and you should scan for a String.</p>

<p>Try this:</p>

<pre><code>import java.util.Scanner;
public class Final1 {
   public static void main (String[] args) {
      int x=0;

      Scanner s = new Scanner(System.in);

      String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

      System.out.print(""Enter String Name:"");
         String y=s.nextLine();

            for (String a: names){
               if (a.equals(y)) 
                  System.out.println(y);   
            }

   }
}
</code></pre>",50147769,2,java|arrays|string|java.util.scanner
How to find if a string entered into scanner is in an array?,"<p>I have to: </p>

<p>Prompt the user for a string,
if the string entered is in the array ""names"", print out its index,
if not in names, print out ""NOT FOUND""</p>

<p>this is what I have:</p>

<p>This is for my programming final and i can't figure out how to do this because I missed 1 class...</p>

<pre><code>import java.util.Scanner;
public class Final1 {
   public static void main (String[] args) {
      int y;
      int x=0;

      Scanner s = new Scanner(System.in);

      String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

      System.out.print(""Enter String Name:"");
         y=s.nextInt();

            for (String a: names){
               if (a.equals(y)) 
                  System.out.println(y);   
            }

   }
}
</code></pre>","<p>The problem is that you get user input as <code>int</code>.</p>

<p>User input values are <code>String</code> in order to check names since names are contained in a <code>String</code> array.</p>

<p>You can try this:</p>

<pre><code>import java.util.Scanner;
public class MyClass {
    public static void main(String args[]) {
       String y;
      int x=0;
      int found = 0; //to identify the index 

      Scanner s = new Scanner(System.in);

      String[] names = {""bob"", ""maxwell"", ""charley"", ""tomtomjack""};

      System.out.print(""Enter String Name:"");
         y=s.nextLine();

            for (String a: names){
               if (a.equals(y)) 
                { 
                    System.out.println(""index of ""+a+"" is :""+x);   
                    found++; // increment if found 
                }

                x++;//iterate each time to get the index
            }

            if(found == 0)// check if it is not found
                 System.out.println(""NOT FOUND"");
    }
}
</code></pre>

<p><strong>Output:</strong></p>

<blockquote>
  <p>Enter String Name:charley </p>
  
  <p>index of charley is :2</p>
</blockquote>",50147769,2,java|arrays|string|java.util.scanner
How to model a tree with Hibernate?,"<p>I've got a class called ""Domain"". Each Domain can have multiple sub-domains (of the same type).</p>

<p>I need to be able to determine sub-domains and root-domains. Sub-domains can have sub-domains themself. This can be quite a few levels deep.</p>

<p>Example:</p>

<pre><code>Rootdomain  
|- Subdomain 1  
|   |- Subdomain 2  
|   |
|   |- Subdomain 3
|
|- Subdomain 4
|   |- Subdomain 5
</code></pre>

<p>How do I model such a Java-class with Hibernate annotations?</p>","<p>The modelling would be quite simple:</p>

<pre><code>@Entity
class Domain {
  @ManyToOne //add column definitions as needed
  private Domain parent;      //each Domain with parent==null is a root domain, all others are subdomains

  @OneToMany //add column definitions as needed
  private List&lt;Domain&gt; subdomains;
}
</code></pre>

<p>Note that <code>parent</code> is the property responsible for the database entry, i.e. you need to set <code>parent</code> for a subdomain for the relation to be stored.</p>

<p>What is not quite trivial is the queries, since SQL (and thus HQL and JPQL) doesn't easily support tree queries. Hibernate can do this by lazily loading the next level but if you want to load a bunch of levels in one query, that's where it becomes hard.</p>",7064691,20,java|hibernate|spring
How to model a tree with Hibernate?,"<p>I've got a class called ""Domain"". Each Domain can have multiple sub-domains (of the same type).</p>

<p>I need to be able to determine sub-domains and root-domains. Sub-domains can have sub-domains themself. This can be quite a few levels deep.</p>

<p>Example:</p>

<pre><code>Rootdomain  
|- Subdomain 1  
|   |- Subdomain 2  
|   |
|   |- Subdomain 3
|
|- Subdomain 4
|   |- Subdomain 5
</code></pre>

<p>How do I model such a Java-class with Hibernate annotations?</p>","<p>If you want to use Hibernate/JPA lazy initialization (that is the normal case) then you should <strong>not use the composite pattern</strong>. </p>

<p>The Hibernate related problem with the <a href=""http://en.wikipedia.org/wiki/Composite_pattern"" rel=""noreferrer"">Composite Pattern</a> is: in a Composite you have a Composite that has a reference its child Components.
But the Component is only a abstract class or Interface, so every Component is a Leaf or a Composite.
If you now use lazy initialisation for the cild set of Composite, but then some how need to cast a concrete child to Leaf or Composite, you will get an Cast Exception because hibernate uses a proxy for the component that can not be casted to Leaf or Composite.</p>

<p>The second drawback of the composite pattern is, that every class will be a Leaf or a Composite for its complete lifetime.
That is fine if your structure never changes. But it will not work if a Leaf must become to an Composite because someone wants to add an sub-node/leaf.</p>

<hr>

<p>So if you have some dynamic structure I recommend one class Node that have a bidirectional relatinship between parent and child nodes.
The relationship should be bidirectional if you often need to navigate to parents or childs in your code.
Maintaining that relationship is a bit tricky, so I decided to post some more code.</p>

<pre><code>@Entity
public class Domain {

    @Id
    private long id;

     /** The parent domain, can be null if this is the root domain. */
    @ManyToOne
    private Domain parent;

    /**
     * The children domain of this domain.
     * 
     * This is the inverse side of the parent relation.
     * 
     * &lt;strong&gt;It is the children responsibility to manage there parents children set!&lt;/strong&gt;
     */
    @NotNull
    @OneToMany(mappedBy = ""parent"")
    private Set&lt;Domain&gt; children = new HashSet&lt;Domain&gt;();
    /**
     * Do not use this Constructor!
     * Used only by Hibernate.
     */
    Domain() {
    }

    /**
     * Instantiates a new domain.
     * The domain will be of the same state like the parent domain.
     *
     * @param parent the parent domain
     * @see Domain#createRoot()
     */
    public Domain(final Domain parent) {
        if(parent==null) throw new IllegalArgumentException(""parent required"");

        this.parent = parent;
        registerInParentsChilds();
    }

    /** Register this domain in the child list of its parent. */
    private void registerInParentsChilds() {
        this.parent.children.add(this);
    }

    /**
     * Return the &lt;strong&gt;unmodifiable&lt;/strong&gt; children of this domain.
     * 
     * @return the child nodes.
     */
    public Set&lt;Domain&gt; getChildren() {
        return Collections.unmodifiableSet(this.children);
    }        

    /**
     * Move this domain to an new parent domain.
     *
     * @param newParent the new parent
     */
    public void move(final Domain newParent)  {
        Check.notNullArgument(newParent, ""newParent"");

        if (!isProperMoveTarget(newParent) /* detect circles... */ ) { 
            throw new IllegalArgumentException(""move"", ""not a proper new parent"", this);
        }

        this.parent.children.remove(this);
        this.parent = newParent;
        registerInParentsChilds();
    }

    /**
     * Creates the root.
     *
     * @param bid the bid
     * @return the domain
     */
    public static Domain createRoot() {
        return new Domain();
    }
}
</code></pre>",7064691,10,java|hibernate|spring
How to perform sorting based on Comparator keeping original sort intact in Java,"<p>I've been going through implementation examples of Comparable vs Comparator interface.</p>

<p>But, I've been stuck at one point in it's implementation :</p>

<p>Suppose, I've a simple class : Employee which has a default sorting mechanism based on employee name.</p>

<pre><code>public class Employee implements Comparable&lt;Employee&gt; {

   private int empSalary;
   private String empName;

   @Override
   public int compareTo(Employee e) {
        return this.empName.compareTo(e.empName);
   }

}
</code></pre>

<p>But, let's say, I've to sort based on employee name first, and then if two employess have same name, i've to sort them according to their salary.</p>

<p>So, I wrote a custom comparator to sort based on salary like below</p>

<pre><code>public class SalaryComparator implements Comparator&lt;Employee&gt; {

      @Override
      public int compare(Employee e1, Employee e2)  {
        return e1.empSalary - e2.empSalary;
      }

}
</code></pre>

<p>But, when I ran my test class to sort based on name first, salary second, the output is not as what is expected.</p>

<pre><code>Collections.sort(employeeList, new SalaryComparator());
</code></pre>

<p>Input Order :</p>

<pre><code>Name : Kumar, Salary : 40
Name : Sanket, Salary : 10
Name : Kumar, Salary : 20
</code></pre>

<p>Expected output :</p>

<pre><code>Name : Kumar, Salary : 20
Name : Kumar, Salary : 40
Name : Sanket, Salary : 10
</code></pre>

<p>Actual Output :</p>

<pre><code>Name : Sanket, Salary : 10 // incorrect order
Name : Kumar, Salary : 20
Name : Kumar, Salary : 40
</code></pre>","<p>If you wanted to create a custom comparator to separate name-ties based on salary, have the comparator first try to compare the two employees, then if that's a tie, use salary:</p>

<pre><code>public class SalaryComparator implements Comparator&lt;Employee&gt; {

    @Override
    public int compare(Employee e1, Employee e2)  {
        if (e1.compareTo(e2) == 0)
            return e1.empSalary - e2.empSalary;
        return e1.compareTo(e2);
    }
}
</code></pre>",22607013,0,java|sorting|collections|comparator|comparable
How to perform sorting based on Comparator keeping original sort intact in Java,"<p>I've been going through implementation examples of Comparable vs Comparator interface.</p>

<p>But, I've been stuck at one point in it's implementation :</p>

<p>Suppose, I've a simple class : Employee which has a default sorting mechanism based on employee name.</p>

<pre><code>public class Employee implements Comparable&lt;Employee&gt; {

   private int empSalary;
   private String empName;

   @Override
   public int compareTo(Employee e) {
        return this.empName.compareTo(e.empName);
   }

}
</code></pre>

<p>But, let's say, I've to sort based on employee name first, and then if two employess have same name, i've to sort them according to their salary.</p>

<p>So, I wrote a custom comparator to sort based on salary like below</p>

<pre><code>public class SalaryComparator implements Comparator&lt;Employee&gt; {

      @Override
      public int compare(Employee e1, Employee e2)  {
        return e1.empSalary - e2.empSalary;
      }

}
</code></pre>

<p>But, when I ran my test class to sort based on name first, salary second, the output is not as what is expected.</p>

<pre><code>Collections.sort(employeeList, new SalaryComparator());
</code></pre>

<p>Input Order :</p>

<pre><code>Name : Kumar, Salary : 40
Name : Sanket, Salary : 10
Name : Kumar, Salary : 20
</code></pre>

<p>Expected output :</p>

<pre><code>Name : Kumar, Salary : 20
Name : Kumar, Salary : 40
Name : Sanket, Salary : 10
</code></pre>

<p>Actual Output :</p>

<pre><code>Name : Sanket, Salary : 10 // incorrect order
Name : Kumar, Salary : 20
Name : Kumar, Salary : 40
</code></pre>","<p>Note that you can do it the following way in Java 8:</p>

<pre><code>public class Employee {
    private int empSalary;
    private String empName;

    public int getEmpSalary() {
        return empSalary;
    }

    public String getEmpName() {
        return empName;
    }
}
</code></pre>

<p>Note that I added a public getter, then for <strong>simple comparison</strong>:</p>

<pre><code>List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;();
// Populate it
employeeList.sort(Comparator.comparingInt(Employee::getEmpSalary));
</code></pre>

<p>This will create a <code>Comparator&lt;Employee&gt;</code> that compares the integer values returned by <code>Employee.getEmpSalary()</code>, I am using a method reference there, which is a fancy way of writing <code>employee -&gt; employee.getEmpSalary()</code>, which is a lambda function mapping from <code>Employee</code> to <code>int</code>.</p>

<p>For reverse you could use:</p>

<pre><code>employeeList.sort(Comparator.comparingInt(Employee::getEmpSalary).reversed());
</code></pre>

<p>Now if you want to compare first the name, and the salary, you can use:</p>

<pre><code>employeeList.sort(
        Comparator.comparing(Employee::getEmpName)
        .thenComparingInt(Employee::getEmpSalary)
</code></pre>",22607013,0,java|sorting|collections|comparator|comparable
How to perform sorting based on Comparator keeping original sort intact in Java,"<p>I've been going through implementation examples of Comparable vs Comparator interface.</p>

<p>But, I've been stuck at one point in it's implementation :</p>

<p>Suppose, I've a simple class : Employee which has a default sorting mechanism based on employee name.</p>

<pre><code>public class Employee implements Comparable&lt;Employee&gt; {

   private int empSalary;
   private String empName;

   @Override
   public int compareTo(Employee e) {
        return this.empName.compareTo(e.empName);
   }

}
</code></pre>

<p>But, let's say, I've to sort based on employee name first, and then if two employess have same name, i've to sort them according to their salary.</p>

<p>So, I wrote a custom comparator to sort based on salary like below</p>

<pre><code>public class SalaryComparator implements Comparator&lt;Employee&gt; {

      @Override
      public int compare(Employee e1, Employee e2)  {
        return e1.empSalary - e2.empSalary;
      }

}
</code></pre>

<p>But, when I ran my test class to sort based on name first, salary second, the output is not as what is expected.</p>

<pre><code>Collections.sort(employeeList, new SalaryComparator());
</code></pre>

<p>Input Order :</p>

<pre><code>Name : Kumar, Salary : 40
Name : Sanket, Salary : 10
Name : Kumar, Salary : 20
</code></pre>

<p>Expected output :</p>

<pre><code>Name : Kumar, Salary : 20
Name : Kumar, Salary : 40
Name : Sanket, Salary : 10
</code></pre>

<p>Actual Output :</p>

<pre><code>Name : Sanket, Salary : 10 // incorrect order
Name : Kumar, Salary : 20
Name : Kumar, Salary : 40
</code></pre>","<p>Instead of creating a new Comparator with all your conditions in it, like suggested by others, you can also sort multiple time.</p>

<p>So if you replace your sort part with this:</p>

<pre><code>Collections.sort(employeeList, new SalaryComparator());
Collections.sort(employeeList);
</code></pre>

<p>Then you'll have your expected output.  </p>

<p>It might be less efficient than sorting everything at the same time with a combined comparator, but it is quite handy when you need to sort with multiple properties.</p>

<p>And if you really need to have a powerful way of sort by different properties (like in a table), then you should try to create a chain of comparators.<br>
Here is an example of such a pattern:<br>
<a href=""http://commons.apache.org/proper/commons-collections/javadocs/api-2.1.1/org/apache/commons/collections/comparators/ComparatorChain.html"" rel=""nofollow"">http://commons.apache.org/proper/commons-collections/javadocs/api-2.1.1/org/apache/commons/collections/comparators/ComparatorChain.html</a><br>
(This is the old way to do what is proposed in the answer using Java8 :)</p>",22607013,0,java|sorting|collections|comparator|comparable
How to perform sorting based on Comparator keeping original sort intact in Java,"<p>I've been going through implementation examples of Comparable vs Comparator interface.</p>

<p>But, I've been stuck at one point in it's implementation :</p>

<p>Suppose, I've a simple class : Employee which has a default sorting mechanism based on employee name.</p>

<pre><code>public class Employee implements Comparable&lt;Employee&gt; {

   private int empSalary;
   private String empName;

   @Override
   public int compareTo(Employee e) {
        return this.empName.compareTo(e.empName);
   }

}
</code></pre>

<p>But, let's say, I've to sort based on employee name first, and then if two employess have same name, i've to sort them according to their salary.</p>

<p>So, I wrote a custom comparator to sort based on salary like below</p>

<pre><code>public class SalaryComparator implements Comparator&lt;Employee&gt; {

      @Override
      public int compare(Employee e1, Employee e2)  {
        return e1.empSalary - e2.empSalary;
      }

}
</code></pre>

<p>But, when I ran my test class to sort based on name first, salary second, the output is not as what is expected.</p>

<pre><code>Collections.sort(employeeList, new SalaryComparator());
</code></pre>

<p>Input Order :</p>

<pre><code>Name : Kumar, Salary : 40
Name : Sanket, Salary : 10
Name : Kumar, Salary : 20
</code></pre>

<p>Expected output :</p>

<pre><code>Name : Kumar, Salary : 20
Name : Kumar, Salary : 40
Name : Sanket, Salary : 10
</code></pre>

<p>Actual Output :</p>

<pre><code>Name : Sanket, Salary : 10 // incorrect order
Name : Kumar, Salary : 20
Name : Kumar, Salary : 40
</code></pre>","<p>This is not because your <code>Employee</code> class already has a default ordering, that using <code>Collections.sort</code> with a custom comparator will introduce a new layer of ordering.</p>

<p>For example let's say that the default ordering of your <code>Employees</code> is by their salary in ascending order. Now let's say you want to sort them by salary in descending order.</p>

<p>According to your logic how this will behave?</p>

<pre><code>Collections.sort(employees, new SalaryDescendingComparator());
</code></pre>

<p>The fact is that when you provide a custom comparator to <code>Collections.sort</code>, it will use only this one and not the sorting mechanism that you implemented in your <code>Employee</code> class. </p>

<p>As the <a href=""http://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort%28java.util.List,%20java.util.Comparator%29"" rel=""nofollow"">doc</a> states:</p>

<blockquote>
  <p>Sorts the specified list according to the order induced by the
  specified comparator.</p>
</blockquote>

<p>So because the <code>SalaryComparator</code> compares employees only by their salary, that's why you get this output.</p>

<p>If you want to sort by name first and then by salary, you'll have to do this in one time, i.e :</p>

<pre><code>public class Employee implements Comparable&lt;Employee&gt; {

   private int empSalary;
   private String empName;

   @Override
   public int compareTo(Employee e) {
       int cmp = this.empName.compareTo(e.empName);
       return cmp != 0 ? cmp : Integer.compare(empSalary, e.empSalary);
   }

}
</code></pre>",22607013,6,java|sorting|collections|comparator|comparable
Finding the shortest distance between two nodes,"<p>I found and implemented Dijkstra's algorithm into a graph that I had created - which shows a map of my local area 
<a href=""https://i.stack.imgur.com/RSYf1.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RSYf1.jpg"" alt=""enter image description here""></a></p>

<p>The code works fine but I want it to display all the nodes that it visited in order to get to the location Node from the source node. So for example: if I set the source node at 1 (Banstead), and the location node to 4 (Whteleafe) - I want it to perhaps store in an array the nodes it visited like Array = {1,2,4} Any ideas? I want to put this on an FXML file and have the nodes as ellipses and connecting them with lines - but in order to do so I need to store that values of the nodes visited.</p>

<pre><code>package dijkstras;

public class Dijkstras {

static class createGraph{
int vertices;
int matrix[][];

public createGraph(int vertex){

this.vertices = vertex;
matrix = new int[vertex][vertex];
}

public void edge(int source, int destination, int weight){

matrix[source][destination] = weight;
matrix[destination][source] = weight;
}

int getMinVertex(boolean [] mst, int [] key){
int minKey = Integer.MAX_VALUE;
int vertex = -1;
for (int i = 1; i &lt; vertices; i++) {
if(mst[i]==false &amp;&amp; minKey&gt;key[i]){
minKey = key[i];
vertex =i;
}
}

return vertex; 
}

public void dijkstras(int sourceVertex){
boolean[] spt = new boolean[vertices];
int [] distance = new int[vertices];
int infinity = Integer.MAX_VALUE;

//setting all distances to infinity
for(int i=1; i&lt;vertices; i++){
distance[i] = infinity;
}

//test for starting vertext = 1
distance[sourceVertex] = 1;

//create tree
for(int i=1; i&lt;vertices; i++){

int vertexU = getMinVertex(spt, distance);

spt[vertexU] = true; 
//go through all possible paths adjacent to vertex
for(int vertexV=1; vertexV&lt;vertices; vertexV++){
//check if edge between Vu and Vv exists
if(matrix[vertexU][vertexV]&gt;0){

//checks vertexV exists and if distance is not infinite
if(spt[vertexV]==false &amp;&amp; matrix[vertexU][vertexV]!=infinity){

int newKey = matrix[vertexU][vertexV] + distance[vertexU];
if(newKey&lt;distance[vertexV])
distance[vertexV] = newKey;
}
}
}
}

System.out.println(); 
printDijkstras(sourceVertex, distance);
}

public void printDijkstras(int sourceVertex, int [] key){
System.out.println(""Dijkstra Algorithm:"");
int LocationOfChosenUser = 10; 
System.out.println(""Source Vertex: ""+ sourceVertex + "" to "" +
LocationOfChosenUser + "" distance: "" + (key[LocationOfChosenUser]-1));
}
}

public static void graph() {
int vertices = 18;
createGraph graph = new createGraph(vertices);
int sourceVertex = 8;
//adding all nodes
graph.edge(1,2,4); graph.edge(1,17,3); 
graph.edge(2,1,4); graph.edge(2,4,4); graph.edge(2,10,5); 
graph.edge(3,4,1); graph.edge(3,6,5); graph.edge(3,5,2);
graph.edge(4,2,4); graph.edge(4,3,1); graph.edge(4,5,2); 
graph.edge(5,4,2); graph.edge(5,3,2); graph.edge(5,6,3); graph.edge(5,9,4); graph.edge(5,10,5); 
graph.edge(6,3,5); graph.edge(6,5,3); graph.edge(6,7,2); graph.edge(6,9,2);
graph.edge(7,6,2); graph.edge(7,8,5); 
graph.edge(8,7,5); graph.edge(8,9,4); graph.edge(8,12,5);
graph.edge(9,5,4); graph.edge(9,8,4); graph.edge(9,11,5); graph.edge(9,6,2); 
graph.edge(10,2,5); graph.edge(10,5,5); graph.edge(10,13,1);graph.edge(10,14,3); graph.edge(10,17,6);
graph.edge(11,9,5); graph.edge(11,12,3); graph.edge(11,13,3);
graph.edge(12,8,5); graph.edge(12,11,3); graph.edge(12,15,4);
graph.edge(13,11,3); graph.edge(13,10,1); graph.edge(13,14,2);
graph.edge(14,10,3); graph.edge(14,13,2); graph.edge(14,16,6); graph.edge(14,15,6);
graph.edge(15,12,4); graph.edge(15,14,5); graph.edge(15,16,9); 
graph.edge(16,15,9); graph.edge(16,17,1); graph.edge(16,14,6);
graph.edge(17,1,3); graph.edge(17,16,1);

graph.dijkstras(sourceVertex);
}
public static void main(String[] args){
graph();
}
}
</code></pre>

<p>As you can see I set the sourceVertex to 8 and the LocationVertex (LocationOfChosenUser) to 10. and the output looks something like this:</p>

<pre><code> Dijkstra Algorithm:
Source Vertex: 8 to 10 distance: 12
</code></pre>","<p>Easiest way of doing this is to just keep track of the predecessors of each node. When you've reached the end node you can then backtrack to find out where you came from.</p>

<p>Add initialization</p>

<pre><code>int [] comeFrom = new int[vertices];
</code></pre>

<p>Change </p>

<pre><code>if(newKey&lt;distance[vertexV])
distance[vertexV] = newKey;
</code></pre>

<p>to</p>

<pre><code>if(newKey&lt;distance[vertexV]) {
distance[vertexV] = newKey;
comeFrom[vertexV] = vertexU;
}
</code></pre>

<p>and when printing out</p>

<pre><code>List&lt;Integer&gt; path = new ArrayList();
int pos = LocationOfChosenUser;

while(pos != sourceVertex) {
path.add(pos);
pos = comeFrom[pos];
}

for (int i=path.size()-1; i&gt;=0; i--) {
System.out.print(path.get(i));
if (i &gt; 0) System.out.print("" -&gt; "");
}
</code></pre>",55098831,0,java|matrix|dijkstra
Finding the shortest distance between two nodes,"<p>I found and implemented Dijkstra's algorithm into a graph that I had created - which shows a map of my local area 
<a href=""https://i.stack.imgur.com/RSYf1.jpg"" rel=""nofollow noreferrer""><img src=""https://i.stack.imgur.com/RSYf1.jpg"" alt=""enter image description here""></a></p>

<p>The code works fine but I want it to display all the nodes that it visited in order to get to the location Node from the source node. So for example: if I set the source node at 1 (Banstead), and the location node to 4 (Whteleafe) - I want it to perhaps store in an array the nodes it visited like Array = {1,2,4} Any ideas? I want to put this on an FXML file and have the nodes as ellipses and connecting them with lines - but in order to do so I need to store that values of the nodes visited.</p>

<pre><code>package dijkstras;

public class Dijkstras {

static class createGraph{
int vertices;
int matrix[][];

public createGraph(int vertex){

this.vertices = vertex;
matrix = new int[vertex][vertex];
}

public void edge(int source, int destination, int weight){

matrix[source][destination] = weight;
matrix[destination][source] = weight;
}

int getMinVertex(boolean [] mst, int [] key){
int minKey = Integer.MAX_VALUE;
int vertex = -1;
for (int i = 1; i &lt; vertices; i++) {
if(mst[i]==false &amp;&amp; minKey&gt;key[i]){
minKey = key[i];
vertex =i;
}
}

return vertex; 
}

public void dijkstras(int sourceVertex){
boolean[] spt = new boolean[vertices];
int [] distance = new int[vertices];
int infinity = Integer.MAX_VALUE;

//setting all distances to infinity
for(int i=1; i&lt;vertices; i++){
distance[i] = infinity;
}

//test for starting vertext = 1
distance[sourceVertex] = 1;

//create tree
for(int i=1; i&lt;vertices; i++){

int vertexU = getMinVertex(spt, distance);

spt[vertexU] = true; 
//go through all possible paths adjacent to vertex
for(int vertexV=1; vertexV&lt;vertices; vertexV++){
//check if edge between Vu and Vv exists
if(matrix[vertexU][vertexV]&gt;0){

//checks vertexV exists and if distance is not infinite
if(spt[vertexV]==false &amp;&amp; matrix[vertexU][vertexV]!=infinity){

int newKey = matrix[vertexU][vertexV] + distance[vertexU];
if(newKey&lt;distance[vertexV])
distance[vertexV] = newKey;
}
}
}
}

System.out.println(); 
printDijkstras(sourceVertex, distance);
}

public void printDijkstras(int sourceVertex, int [] key){
System.out.println(""Dijkstra Algorithm:"");
int LocationOfChosenUser = 10; 
System.out.println(""Source Vertex: ""+ sourceVertex + "" to "" +
LocationOfChosenUser + "" distance: "" + (key[LocationOfChosenUser]-1));
}
}

public static void graph() {
int vertices = 18;
createGraph graph = new createGraph(vertices);
int sourceVertex = 8;
//adding all nodes
graph.edge(1,2,4); graph.edge(1,17,3); 
graph.edge(2,1,4); graph.edge(2,4,4); graph.edge(2,10,5); 
graph.edge(3,4,1); graph.edge(3,6,5); graph.edge(3,5,2);
graph.edge(4,2,4); graph.edge(4,3,1); graph.edge(4,5,2); 
graph.edge(5,4,2); graph.edge(5,3,2); graph.edge(5,6,3); graph.edge(5,9,4); graph.edge(5,10,5); 
graph.edge(6,3,5); graph.edge(6,5,3); graph.edge(6,7,2); graph.edge(6,9,2);
graph.edge(7,6,2); graph.edge(7,8,5); 
graph.edge(8,7,5); graph.edge(8,9,4); graph.edge(8,12,5);
graph.edge(9,5,4); graph.edge(9,8,4); graph.edge(9,11,5); graph.edge(9,6,2); 
graph.edge(10,2,5); graph.edge(10,5,5); graph.edge(10,13,1);graph.edge(10,14,3); graph.edge(10,17,6);
graph.edge(11,9,5); graph.edge(11,12,3); graph.edge(11,13,3);
graph.edge(12,8,5); graph.edge(12,11,3); graph.edge(12,15,4);
graph.edge(13,11,3); graph.edge(13,10,1); graph.edge(13,14,2);
graph.edge(14,10,3); graph.edge(14,13,2); graph.edge(14,16,6); graph.edge(14,15,6);
graph.edge(15,12,4); graph.edge(15,14,5); graph.edge(15,16,9); 
graph.edge(16,15,9); graph.edge(16,17,1); graph.edge(16,14,6);
graph.edge(17,1,3); graph.edge(17,16,1);

graph.dijkstras(sourceVertex);
}
public static void main(String[] args){
graph();
}
}
</code></pre>

<p>As you can see I set the sourceVertex to 8 and the LocationVertex (LocationOfChosenUser) to 10. and the output looks something like this:</p>

<pre><code> Dijkstra Algorithm:
Source Vertex: 8 to 10 distance: 12
</code></pre>","<p>Every time you update your distance array, you need to keep track of what path was taken to reach the node. This can be done several ways, and I recommend an array that stores which step was taken to achieve the distance in the distance array.</p>

<pre><code>distance[vertexV] = newKey;
lastStep[vertexV] = vertexU;
</code></pre>

<p>When the algorithm is done, you can then traverse the path from the destination back to the start. Basically, you do this:</p>

<pre><code>int location = LocationOfChosenUser;
System.out.print(LocationOfChosenUser);
while (location != sourceVertex) {
location = lastStep[LocationOfChosenUser];
System.out.print("" &lt;- "" + location);
}
System.out.println();
</code></pre>

<p>This order gives you the reverse order (therefore, the <code>&lt;-</code> arrow). How you would store the numbers and reverse it is left as an exercise for you.</p>",55098831,0,java|matrix|dijkstra
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>Now it's 2017, The latest version of XStream requires a converter to make it works as your expected. </p>

<p>A converter supports nested map:</p>

<pre><code>public class MapEntryConverter implements Converter {

@Override
public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext marshallingContext) {
AbstractMap map = (AbstractMap) value;
for (Object obj : map.entrySet()) {
Map.Entry entry = (Map.Entry) obj;
writer.startNode(entry.getKey().toString());
Object val = entry.getValue();
if (val instanceof Map) {
marshal(val, writer, marshallingContext);
} else if (null != val) {
writer.setValue(val.toString());
}
writer.endNode();
}
}

@Override
public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext unmarshallingContext) {
Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();

while(reader.hasMoreChildren()) {
reader.moveDown();

String key = reader.getNodeName(); // nodeName aka element's name
String value = reader.getValue().replaceAll(""\\n|\\t"", """");
if (StringUtils.isBlank(value)) {
map.put(key, unmarshal(reader, unmarshallingContext));
} else {
map.put(key, value);
}

reader.moveUp();
}

return map;
}

@Override
public boolean canConvert(Class clazz) {
return AbstractMap.class.isAssignableFrom(clazz);
}
} 
</code></pre>",1537207,1,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>In my case I convert DBresponse to XML in Camel ctx.
JDBC executor return the ArrayList (rows) with LinkedCaseInsensitiveMap (single row). 
Task - create XML object based on DBResponce. </p>

<pre><code>import java.io.StringWriter;
import java.util.ArrayList;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.springframework.util.LinkedCaseInsensitiveMap;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

public class ConvertDBToXMLProcessor implements Processor {

public void process(List body) {

if (body instanceof ArrayList) {
ArrayList&lt;LinkedCaseInsensitiveMap&gt; rows = (ArrayList) body;

DocumentBuilder builder = null;
builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
Document document = builder.newDocument();
Element rootElement = document.createElement(""DBResultSet"");

for (LinkedCaseInsensitiveMap row : rows) {
Element newNode = document.createElement(""Row"");
row.forEach((key, value) -&gt; {
if (value != null) {
Element newKey = document.createElement((String) key);
newKey.setTextContent(value.toString());
newNode.appendChild(newKey);
}
});
rootElement.appendChild(newNode);
}
document.appendChild(rootElement);


/* 
* If you need return string view instead org.w3c.dom.Document
*/
StringWriter writer = new StringWriter();
StreamResult result = new StreamResult(writer);
DOMSource domSource = new DOMSource(document);
TransformerFactory tf = TransformerFactory.newInstance();
Transformer transformer = tf.newTransformer();
transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");
transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, ""no"");
transformer.transform(domSource, result);

// return document
// return writer.toString()

}
}
}
</code></pre>",1537207,0,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>I have tried different kinds of maps and the <a href=""http://capsulesforthejavamind.blogspot.in/2015/01/conversion-box.html"" rel=""nofollow"">Conversion Box</a> worked. I have used your map and have pasted an example below with some inner maps. Hope it is helpful to you .... </p>

<pre><code>import java.util.HashMap;
import java.util.Map;

import cjm.component.cb.map.ToMap;
import cjm.component.cb.xml.ToXML;

public class Testing
{
public static void main(String[] args)
{
try
{
Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); // ORIGINAL MAP

map.put(""name"", ""chris"");
map.put(""island"", ""faranga"");

Map&lt;String, String&gt; mapInner = new HashMap&lt;String, String&gt;(); // SAMPLE INNER MAP

mapInner.put(""a"", ""A"");
mapInner.put(""b"", ""B"");
mapInner.put(""c"", ""C"");

map.put(""innerMap"", mapInner);

Map&lt;String, Object&gt; mapRoot = new HashMap&lt;String, Object&gt;(); // ROOT MAP

mapRoot.put(""ROOT"", map);

System.out.println(""Map: "" + mapRoot);

System.out.println();

ToXML toXML = new ToXML();

String convertedXML = String.valueOf(toXML.convertToXML(mapRoot, true)); // CONVERTING ROOT MAP TO XML

System.out.println(""Converted XML: "" + convertedXML);

System.out.println();

ToMap toMap = new ToMap();

Map&lt;String, Object&gt; convertedMap = toMap.convertToMap(convertedXML); // CONVERTING CONVERTED XML BACK TO MAP

System.out.println(""Converted Map: "" + convertedMap);
}
catch (Exception e)
{
e.printStackTrace();
}
}
}
</code></pre>

<p>Output:</p>

<pre><code>Map: {ROOT={name=chris, innerMap={b=B, c=C, a=A}, island=faranga}}

-------- Map Detected -------- 
-------- XML created Successfully -------- 
Converted XML: &lt;ROOT&gt;&lt;name&gt;chris&lt;/name&gt;&lt;innerMap&gt;&lt;b&gt;B&lt;/b&gt;&lt;c&gt;C&lt;/c&gt;&lt;a&gt;A&lt;/a&gt;&lt;/innerMap&gt;&lt;island&gt;faranga&lt;/island&gt;&lt;/ROOT&gt;

-------- XML Detected -------- 
-------- Map created Successfully -------- 
Converted Map: {ROOT={name=chris, innerMap={b=B, c=C, a=A}, island=faranga}}
</code></pre>",1537207,1,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>I have written a piece of code that transforms a XML content into a multi-layer structure of maps:</p>

<pre><code>public static Object convertNodesFromXml(String xml) throws Exception {

InputStream is = new ByteArrayInputStream(xml.getBytes());
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
dbf.setNamespaceAware(true);
DocumentBuilder db = dbf.newDocumentBuilder();
Document document = db.parse(is);
return createMap(document.getDocumentElement());
}

public static Object createMap(Node node) {
Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
NodeList nodeList = node.getChildNodes();
for (int i = 0; i &lt; nodeList.getLength(); i++) {
Node currentNode = nodeList.item(i);
String name = currentNode.getNodeName();
Object value = null;
if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
value = createMap(currentNode);
}
else if (currentNode.getNodeType() == Node.TEXT_NODE) {
return currentNode.getTextContent();
}
if (map.containsKey(name)) {
Object os = map.get(name);
if (os instanceof List) {
((List&lt;Object&gt;)os).add(value);
}
else {
List&lt;Object&gt; objs = new LinkedList&lt;Object&gt;();
objs.add(os);
objs.add(value);
map.put(name, objs);
}
}
else {
map.put(name, value);
}
}
return map;
}
</code></pre>

<p>This code transforms this:</p>

<pre><code>&lt;house&gt;
&lt;door&gt;blue&lt;/door&gt;
&lt;living-room&gt;
&lt;table&gt;wood&lt;/table&gt;
&lt;chair&gt;wood&lt;/chair&gt;
&lt;/living-room&gt;
&lt;/house&gt;
</code></pre>

<p>into</p>

<pre><code>{
""house"": {
""door"": ""blue"",
""living-room"": {
""table"": ""wood"",
""chair"": ""wood""
}
}
}
</code></pre>

<p>I don't have the inverse process, but that must not be very difficult to write.</p>",1537207,4,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>If you only need to convert simple map to xml, without nested properties, then the lightweight solution would be just a private method, as follows:</p>

<pre><code>private String convertMapToXML(Map&lt;String, String&gt; map) {
StringBuilder xmlBuilder = new StringBuilder();
xmlBuilder.append(""&lt;xml&gt;"");
for (Map.Entry&lt;String, String&gt; entry : map.entrySet()) {
if (entry.getValue() != null) {
String xmlElement = entry.getKey();
xmlBuilder.append(""&lt;"");
xmlBuilder.append(xmlElement);
xmlBuilder.append(""&gt;"");
xmlBuilder.append(entry.getValue());
xmlBuilder.append(""&lt;"");
xmlBuilder.append(""/"");
xmlBuilder.append(xmlElement); 
xmlBuilder.append(""&gt;"");
} 
}

xmlBuilder.append(""&lt;/xml&gt;"");
return xmlBuilder.toString();
}
</code></pre>",1537207,0,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>One option would be to roll your own. It would be fairly simple to do:</p>

<pre><code>Document doc = getDocument();
Element root = doc.createElement(rootName);
doc.appendChild(root);
for (Map.Entry&lt;String,String&gt; element : map.entrySet() ) {
Element e = doc.createElement(element.getKey());
e.setTextContent(element.getValue());
root.appendChild(e);
}
save(doc, file);
</code></pre>

<p>and the load is an equally simply <code>getChildNodes</code> and a loop. Sure it has a bit of boiler plate that the XML Gods demand but it is at most 1 hours work. </p>

<p>Or you could look at <a href=""http://java.sun.com/javase/6/docs/api/java/util/Properties.html#storeToXML%28java.io.OutputStream,%20java.lang.String,%20java.lang.String%29"" rel=""noreferrer"">Properties</a> if you are not too fused about the format of the XML.</p>",1537207,8,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>XStream!</p>

<p><strong>Updated</strong>: I added unmarshal part as requested in comments..</p>

<pre><code>import com.thoughtworks.xstream.XStream;
import com.thoughtworks.xstream.converters.Converter;
import com.thoughtworks.xstream.converters.MarshallingContext;
import com.thoughtworks.xstream.converters.UnmarshallingContext;
import com.thoughtworks.xstream.io.HierarchicalStreamReader;
import com.thoughtworks.xstream.io.HierarchicalStreamWriter;

import java.util.AbstractMap;
import java.util.HashMap;
import java.util.Map;

public class Test {

public static void main(String[] args) {

Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

XStream magicApi = new XStream();
magicApi.registerConverter(new MapEntryConverter());
magicApi.alias(""root"", Map.class);

String xml = magicApi.toXML(map);
System.out.println(""Result of tweaked XStream toXml()"");
System.out.println(xml);

Map&lt;String, String&gt; extractedMap = (Map&lt;String, String&gt;) magicApi.fromXML(xml);
assert extractedMap.get(""name"").equals(""chris"");
assert extractedMap.get(""island"").equals(""faranga"");

}

public static class MapEntryConverter implements Converter {

public boolean canConvert(Class clazz) {
return AbstractMap.class.isAssignableFrom(clazz);
}

public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {

AbstractMap map = (AbstractMap) value;
for (Object obj : map.entrySet()) {
Map.Entry entry = (Map.Entry) obj;
writer.startNode(entry.getKey().toString());
Object val = entry.getValue();
if ( null != val ) {
writer.setValue(val.toString());
}
writer.endNode();
}

}

public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {

Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

while(reader.hasMoreChildren()) {
reader.moveDown();

String key = reader.getNodeName(); // nodeName aka element's name
String value = reader.getValue();
map.put(key, value);

reader.moveUp();
}

return map;
}

}

}
</code></pre>",1537207,62,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>Here the converter for XStream including unmarshall </p>

<pre><code>public class MapEntryConverter implements Converter{
public boolean canConvert(Class clazz) {
return AbstractMap.class.isAssignableFrom(clazz);
}

public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {
AbstractMap&lt;String,String&gt; map = (AbstractMap&lt;String,String&gt;) value;
for (Entry&lt;String,String&gt; entry : map.entrySet()) {
writer.startNode(entry.getKey().toString());
writer.setValue(entry.getValue().toString());
writer.endNode();
}
}

public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

while(reader.hasMoreChildren()) {
reader.moveDown();
map.put(reader.getNodeName(), reader.getValue());
reader.moveUp();
}
return map;
}
</code></pre>",1537207,44,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p><a href=""https://github.com/javadev/underscore-java"" rel=""nofollow noreferrer"">Underscore-java</a> library can convert Map to xml. I am the maintainer of the project. <a href=""https://www.jdoodle.com/embed/v0/x2h"" rel=""nofollow noreferrer"">Live example</a></p>

<p>Code example:</p>

<pre><code>import com.github.underscore.lodash.U;
import java.util.*;

public class Main {

public static void main(String[] args) {

Map&lt;String, Object&gt; map = new LinkedHashMap&lt;String, Object&gt;();
map.put(""name"", ""chris"");
map.put(""island"", ""faranga"");

System.out.println(U.toXml(map));

// &lt;?xml version=""1.0"" encoding=""UTF-8""?&gt;
// &lt;root&gt;
// &lt;name&gt;chris&lt;/name&gt;
// &lt;island&gt;faranga&lt;/island&gt;
// &lt;/root&gt;

// and back:
map = (Map&lt;String, Object&gt;) U.fromXml(""&lt;?xml version=\""1.0\"" encoding=\""UTF-8\""?&gt;&lt;root&gt;""
+ "" &lt;name&gt;chris&lt;/name&gt;""
+ "" &lt;island&gt;faranga&lt;/island&gt;""
+ "" &lt;/root&gt;"");

System.out.println(map);
// {name=chris, island=faranga}
}
}
</code></pre>",1537207,2,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>I used the approach with the custom converter:</p>

<pre><code>public static class MapEntryConverter implements Converter {

public boolean canConvert(Class clazz) {
return AbstractMap.class.isAssignableFrom(clazz);
}

public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {

AbstractMap map = (AbstractMap) value;
for (Object obj : map.entrySet()) {
Entry entry = (Entry) obj;
writer.startNode(entry.getKey().toString());
context.convertAnother(entry.getValue());
writer.endNode();
}
}

public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {
// dunno, read manual and do it yourself ;)
}

}
</code></pre>

<p>But i changed the the serialization of the maps value to delegate to the MarshallingContext. This should improve the solution to work for composite map values and nested maps as well.</p>",1537207,6,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>I found this on google, but I don't want to use XStream, because it causes to much overhead in my environment. I only needed to parse a file and since I did not find anything I like I created my own simple solution for parsing a file of the format that you describe. So here is my solution:</p>

<pre><code>public class XmlToMapUtil {
public static Map&lt;String, String&gt; parse(InputSource inputSource) throws SAXException, IOException, ParserConfigurationException {
final DataCollector handler = new DataCollector();
SAXParserFactory.newInstance().newSAXParser().parse(inputSource, handler);
return handler.result;
}

private static class DataCollector extends DefaultHandler {
private final StringBuilder buffer = new StringBuilder();
private final Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;();

@Override
public void endElement(String uri, String localName, String qName) throws SAXException {
final String value = buffer.toString().trim();
if (value.length() &gt; 0) {
result.put(qName, value);
}
buffer.setLength(0);
}

@Override
public void characters(char[] ch, int start, int length) throws SAXException {
buffer.append(ch, start, length);
}
}
}
</code></pre>

<p>Here are a couple of TestNG+FEST Assert Tests:</p>

<pre><code>public class XmlToMapUtilTest {

@Test(dataProvider = ""provide_xml_entries"")
public void parse_returnsMapFromXml(String xml, MapAssert.Entry[] entries) throws Exception {
// execution
final Map&lt;String, String&gt; actual = XmlToMapUtil.parse(new InputSource(new StringReader(xml)));

// evaluation
assertThat(actual)
.includes(entries)
.hasSize(entries.length);
}

@DataProvider
public Object[][] provide_xml_entries() {
return new Object[][]{
{""&lt;root /&gt;"", new MapAssert.Entry[0]},

{
""&lt;root&gt;&lt;a&gt;aVal&lt;/a&gt;&lt;/root&gt;"", new MapAssert.Entry[]{
MapAssert.entry(""a"", ""aVal"")
},
},

{
""&lt;root&gt;&lt;a&gt;aVal&lt;/a&gt;&lt;b&gt;bVal&lt;/b&gt;&lt;/root&gt;"", new MapAssert.Entry[]{
MapAssert.entry(""a"", ""aVal""),
MapAssert.entry(""b"", ""bVal"")
},
},

{
""&lt;root&gt; \t &lt;a&gt;\taVal &lt;/a&gt;&lt;b /&gt;&lt;/root&gt;"", new MapAssert.Entry[]{
MapAssert.entry(""a"", ""aVal"")
},
},
};
}
}
</code></pre>",1537207,3,java|xml
How to convert XML to java.util.Map and vice versa,"<p>I'm searching a lightweight API (preferable single class) to convert a</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
</code></pre>

<p>to xml and, vice versa, convert the XML back to a Map.</p>

<p>example:</p>

<pre><code>Map&lt;String,String&gt; map = new HashMap&lt;String,String();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

MagicAPI.toXML(map,""root"");
</code></pre>

<p>result:</p>

<pre><code>&lt;root&gt;
&lt;name&gt;chris&lt;/chris&gt;
&lt;island&gt;faranga&lt;/island&gt;
&lt;/root&gt;
</code></pre>

<p>and back:</p>

<pre><code>Map&lt;String,String&gt; map = MagicAPI.fromXML(""..."");
</code></pre>

<p>I dont want to use <a href=""http://jaxb.java.net/"" rel=""noreferrer"">JAXB</a> or <a href=""http://json.org/java/"" rel=""noreferrer"">JSON conversion API</a>. It doesnt have to take care of nested maps or attributes or anything else, just that simple case.
Any suggestions?</p>

<hr>

<p><strong>Edit</strong>: I created a working copy &amp; paste sample. Thanks to <a href=""https://stackoverflow.com/users/112079/fvu"">fvu</a> and <a href=""https://stackoverflow.com/users/70786/michal-bernhard"">Michal Bernhard</a>.</p>

<p><a href=""http://xstream.codehaus.org/download.html"" rel=""noreferrer"">Download latest XStream framework</a>, 'core only' is enough.</p>

<pre><code>Map&lt;String,Object&gt; map = new HashMap&lt;String,Object&gt;();
map.put(""name"",""chris"");
map.put(""island"",""faranga"");

// convert to XML
XStream xStream = new XStream(new DomDriver());
xStream.alias(""map"", java.util.Map.class);
String xml = xStream.toXML(map);

// from XML, convert back to map
Map&lt;String,Object&gt; map2 = (Map&lt;String,Object&gt;) xStream.fromXML(xml);
</code></pre>

<p>No converters or anything else is required. Just the <a href=""http://repository.codehaus.org/com/thoughtworks/xstream/xstream/1.3.1/xstream-1.3.1.jar"" rel=""noreferrer"">xstream-x.y.z.jar</a> is enough.</p>","<p>I am posting this as an answer not because it's the correct answer to your question, but because it's a solution to the same problem, but using attributes instead. Otherwise Vikas Gujjar's answer is correct.</p>

<p>Quite oftern your data could be in attributes, but it's quite hard to find any working examples using XStream to do this, so here's one:</p>

<p>Sample data:</p>

<pre><code>&lt;settings&gt;
&lt;property name=""prop1"" value=""foo""/&gt;
&lt;property name=""prop2"" /&gt; &lt;!-- NOTE:
The example supports null elements as
the backing object is a HashMap.
A Properties object would be handled
by a PropertiesConverter which wouldn't
allow you null values. --&gt;
&lt;property name=""prop3"" value=""1""/&gt;
&lt;/settings&gt;
</code></pre>

<p>Implementation of MapEntryConverter (slightly re-worked @Vikas Gujjar's implementation to use attributes instead):</p>

<pre><code>public class MapEntryConverter
implements Converter
{

public boolean canConvert(Class clazz)
{
return AbstractMap.class.isAssignableFrom(clazz);
}

public void marshal(Object value,
HierarchicalStreamWriter writer,
MarshallingContext context)
{
//noinspection unchecked
AbstractMap&lt;String, String&gt; map = (AbstractMap&lt;String, String&gt;) value;
for (Map.Entry&lt;String, String&gt; entry : map.entrySet())
{
//noinspection RedundantStringToString
writer.startNode(entry.getKey().toString());
//noinspection RedundantStringToString
writer.setValue(entry.getValue().toString());
writer.endNode();
}
}

public Object unmarshal(HierarchicalStreamReader reader,
UnmarshallingContext context)
{
Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

while (reader.hasMoreChildren())
{
reader.moveDown();
map.put(reader.getAttribute(""name""), reader.getAttribute(""value""));
reader.moveUp();
}

return map;
}
}
</code></pre>

<p>XStream instance setup, parsing and storing:</p>

<pre><code> XStream xstream = new XStream();
xstream.autodetectAnnotations(true);
xstream.alias(""settings"", HashMap.class);
xstream.registerConverter(new MapEntryConverter());
...
// Parse:
YourObject yourObject = (YourObject) xstream.fromXML(is);
// Store:
xstream.toXML(yourObject);
...
</code></pre>",1537207,2,java|xml
Generics and streams: How to make this into a `StreamTuple::new` statement?,"<p>I am working on a small library which emulates multi-value return values in Streams. For this to work well, I would like to be able to use <code>StreamTuple::new</code> instead of <code>StreamTuple::create</code> or <code>id -&gt; new StreamTuple&lt;&gt;(id, id)</code>. I tried various modifications, but my generics-fu is not good enough to figure out how to change the source to allow this.</p>

<pre><code>public class StreamTuple&lt;L, R&gt; {

protected final L left;
protected final R right;

public StreamTuple(L left, R right) {
this.left = left;
this.right = right;
}

/**
* Suitable for method::references. Value is set to id.
*/

public static &lt;L&gt; StreamTuple&lt;L, L&gt; create(L left) {
return new StreamTuple&lt;&gt;(left, left);
}
....
</code></pre>

<p>Calling code snippet:</p>

<pre><code> Map&lt;String, String&gt; m = Stream.of(""1"", ""2"", ""3"")
// .map(StreamTuple::create)
.map(id -&gt; new StreamTuple&lt;&gt;(id, id))
.collect(toMap(StreamTuple::left, StreamTuple::right));
</code></pre>

<p>Suggestions? Or can't it be done?</p>

<hr>

<p>EDIT: I would like an additional constructor that only takes one argument and returns a StreamTuple where L and R is the same type. The current code does not reflect that because it was a while ago I couldn't make it work and I thought I replicated it. I can only find out how to provide one of L / R and that leaves the other one open. How to write a single argument constructor for this?</p>","<p>There's no way to do this with a constructor, because there's no way to specify that the argument is a subtype of both <code>L</code> and <code>R</code> (i.e. conjunction/intersection). The language has a construct for such a requirement, but an intersection between type variables is not allowed:</p>

<pre><code>// not allowed (causes a compilation error)
// vvvvv
public &lt;LR extends L &amp; R&gt; StreamTuple(LR val) {
this.left = val;
this.right = val;
}
</code></pre>

<p>That might work in a future version of Java, however.</p>

<p>You have to use a factory method or, I suppose, what tsolakp suggested. I think the factory makes more sense.</p>",48775814,1,java|generics
Generics and streams: How to make this into a `StreamTuple::new` statement?,"<p>I am working on a small library which emulates multi-value return values in Streams. For this to work well, I would like to be able to use <code>StreamTuple::new</code> instead of <code>StreamTuple::create</code> or <code>id -&gt; new StreamTuple&lt;&gt;(id, id)</code>. I tried various modifications, but my generics-fu is not good enough to figure out how to change the source to allow this.</p>

<pre><code>public class StreamTuple&lt;L, R&gt; {

protected final L left;
protected final R right;

public StreamTuple(L left, R right) {
this.left = left;
this.right = right;
}

/**
* Suitable for method::references. Value is set to id.
*/

public static &lt;L&gt; StreamTuple&lt;L, L&gt; create(L left) {
return new StreamTuple&lt;&gt;(left, left);
}
....
</code></pre>

<p>Calling code snippet:</p>

<pre><code> Map&lt;String, String&gt; m = Stream.of(""1"", ""2"", ""3"")
// .map(StreamTuple::create)
.map(id -&gt; new StreamTuple&lt;&gt;(id, id))
.collect(toMap(StreamTuple::left, StreamTuple::right));
</code></pre>

<p>Suggestions? Or can't it be done?</p>

<hr>

<p>EDIT: I would like an additional constructor that only takes one argument and returns a StreamTuple where L and R is the same type. The current code does not reflect that because it was a while ago I couldn't make it work and I thought I replicated it. I can only find out how to provide one of L / R and that leaves the other one open. How to write a single argument constructor for this?</p>",<p>It can't be done since you're passing <code>id</code> twice. <code>StreamTuple::create</code> is the way to go.</p>,48775814,1,java|generics
Generics and streams: How to make this into a `StreamTuple::new` statement?,"<p>I am working on a small library which emulates multi-value return values in Streams. For this to work well, I would like to be able to use <code>StreamTuple::new</code> instead of <code>StreamTuple::create</code> or <code>id -&gt; new StreamTuple&lt;&gt;(id, id)</code>. I tried various modifications, but my generics-fu is not good enough to figure out how to change the source to allow this.</p>

<pre><code>public class StreamTuple&lt;L, R&gt; {

protected final L left;
protected final R right;

public StreamTuple(L left, R right) {
this.left = left;
this.right = right;
}

/**
* Suitable for method::references. Value is set to id.
*/

public static &lt;L&gt; StreamTuple&lt;L, L&gt; create(L left) {
return new StreamTuple&lt;&gt;(left, left);
}
....
</code></pre>

<p>Calling code snippet:</p>

<pre><code> Map&lt;String, String&gt; m = Stream.of(""1"", ""2"", ""3"")
// .map(StreamTuple::create)
.map(id -&gt; new StreamTuple&lt;&gt;(id, id))
.collect(toMap(StreamTuple::left, StreamTuple::right));
</code></pre>

<p>Suggestions? Or can't it be done?</p>

<hr>

<p>EDIT: I would like an additional constructor that only takes one argument and returns a StreamTuple where L and R is the same type. The current code does not reflect that because it was a while ago I couldn't make it work and I thought I replicated it. I can only find out how to provide one of L / R and that leaves the other one open. How to write a single argument constructor for this?</p>","<p>Stream's <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#map-java.util.function.Function-"" rel=""nofollow noreferrer""><code>map</code> method</a> requires a <code>Function</code> that takes in exactly one parameter and returns something else.</p>

<p>However, what you are attempting to use is <code>StreamTuple::new</code>, and that takes in 2 parameters, e.g. a <code>BiFunction</code>, so that doesn't match.</p>

<p>I suppose you could use <code>flatMap</code> to have two copies of each stream element, then <a href=""https://stackoverflow.com/questions/34086461/java-stream-is-there-a-way-to-iterate-taking-two-elements-a-time-instead-of-one"">write a custom <code>Collector</code></a> to collect these items 2 at a time, but that sounds like a lot more work than referencing your <code>create</code> method, which already matches.</p>

<p>What will work best is what you've done -- a factory method that takes exactly one parameter and returns the desired <code>StreamTuple</code>.</p>",48775814,1,java|generics
Generics and streams: How to make this into a `StreamTuple::new` statement?,"<p>I am working on a small library which emulates multi-value return values in Streams. For this to work well, I would like to be able to use <code>StreamTuple::new</code> instead of <code>StreamTuple::create</code> or <code>id -&gt; new StreamTuple&lt;&gt;(id, id)</code>. I tried various modifications, but my generics-fu is not good enough to figure out how to change the source to allow this.</p>

<pre><code>public class StreamTuple&lt;L, R&gt; {

protected final L left;
protected final R right;

public StreamTuple(L left, R right) {
this.left = left;
this.right = right;
}

/**
* Suitable for method::references. Value is set to id.
*/

public static &lt;L&gt; StreamTuple&lt;L, L&gt; create(L left) {
return new StreamTuple&lt;&gt;(left, left);
}
....
</code></pre>

<p>Calling code snippet:</p>

<pre><code> Map&lt;String, String&gt; m = Stream.of(""1"", ""2"", ""3"")
// .map(StreamTuple::create)
.map(id -&gt; new StreamTuple&lt;&gt;(id, id))
.collect(toMap(StreamTuple::left, StreamTuple::right));
</code></pre>

<p>Suggestions? Or can't it be done?</p>

<hr>

<p>EDIT: I would like an additional constructor that only takes one argument and returns a StreamTuple where L and R is the same type. The current code does not reflect that because it was a while ago I couldn't make it work and I thought I replicated it. I can only find out how to provide one of L / R and that leaves the other one open. How to write a single argument constructor for this?</p>","<p>Have you considered extending <code>StreamTuple</code> in order to define single argument constructor?</p>

<pre><code> Map&lt;String, String&gt; m = Stream.of(""1"", ""2"", ""3"")
.map( UnaryStreamTuple&lt;String&gt;::new )
.collect( Collectors.toMap(UnaryStreamTuple::left, UnaryStreamTuple::right) );

public class UnaryStreamTuple&lt;T&gt; extends StreamTuple&lt;T, T&gt; {

public UnaryStreamTuple(T left) {
super(left, left);
}

public UnaryStreamTuple(T left, T right) {
super(left, right);
} 
}
</code></pre>",48775814,2,java|generics
Generics and streams: How to make this into a `StreamTuple::new` statement?,"<p>I am working on a small library which emulates multi-value return values in Streams. For this to work well, I would like to be able to use <code>StreamTuple::new</code> instead of <code>StreamTuple::create</code> or <code>id -&gt; new StreamTuple&lt;&gt;(id, id)</code>. I tried various modifications, but my generics-fu is not good enough to figure out how to change the source to allow this.</p>

<pre><code>public class StreamTuple&lt;L, R&gt; {

protected final L left;
protected final R right;

public StreamTuple(L left, R right) {
this.left = left;
this.right = right;
}

/**
* Suitable for method::references. Value is set to id.
*/

public static &lt;L&gt; StreamTuple&lt;L, L&gt; create(L left) {
return new StreamTuple&lt;&gt;(left, left);
}
....
</code></pre>

<p>Calling code snippet:</p>

<pre><code> Map&lt;String, String&gt; m = Stream.of(""1"", ""2"", ""3"")
// .map(StreamTuple::create)
.map(id -&gt; new StreamTuple&lt;&gt;(id, id))
.collect(toMap(StreamTuple::left, StreamTuple::right));
</code></pre>

<p>Suggestions? Or can't it be done?</p>

<hr>

<p>EDIT: I would like an additional constructor that only takes one argument and returns a StreamTuple where L and R is the same type. The current code does not reflect that because it was a while ago I couldn't make it work and I thought I replicated it. I can only find out how to provide one of L / R and that leaves the other one open. How to write a single argument constructor for this?</p>","<p><code>StramTuple::new</code> will be translated differently based on the FunctionalInterface expected by the accepting method.</p>

<p>expecting <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html"" rel=""nofollow noreferrer"">Function</a> (T -> R) ==> ::new translates to <code>new StreamTuple(t)</code></p>

<p>expecting <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html"" rel=""nofollow noreferrer"">BiFunction</a> (T,U -> R) ==> ::new translates to <code>new StreamTuple(t,u)</code></p>

<p>expecting <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html"" rel=""nofollow noreferrer"">Supplier</a> (() -> R) ==> ::new translates to <code>new StreamTuple()</code></p>

<p>Since Stream#map is expecting a <a href=""https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html"" rel=""nofollow noreferrer"">Function</a>, this cannot translate to the 2-args constructor. So your <code>create</code> factory method seems a good way to go.</p>

<p>Having a 1-arg contructor (like the below) behaving like the <code>create</code> method is not possible since compiler will complain because R is not bound</p>

<pre><code>public StreamTuple(L both) { //will fail compilation
this.left = both;
this.right = both;
}
</code></pre>

<p><strong>BUT</strong> since you want a 1-arg constructor and its argument must be assignable to both R and L, then you have 2 options:
1) one extends the other (e.g. R is assignable to L)</p>

<pre><code>public class StreamTuple&lt;L, R extends L&gt; {

protected final L left;
protected final R right;

public StreamTuple(R both) {
this.left = both;
this.right = both;
}
}
</code></pre>

<p>2) if R and L are not related, then you need Object with casts on getters:</p>

<pre><code>public class StreamTuple&lt;L, R&gt; {

protected final Object left, right;

public StreamTuple(Object o) {
this.left = this.right = o;
}

public &lt;L&gt; L getLeft() { return (L) left; }
public &lt;R&gt; R getRight() { return (R) right; }
}
</code></pre>",48775814,1,java|generics
How to use BufferedReader to read content in DataInputStream,"<p>I wrote a simple socket tutorial about sending/receive messages between client and server. I used DataOutputStream to write the string in stream but server couldn't read it if I used <strong>BufferedReader</strong></p>

<p>If I use PrintWriter to write(client side), it works.</p>

<p>What's wrong here? Tks so much.</p>

<p><strong>1. Client:</strong> </p>

<pre class=""lang-java prettyprint-override""><code> client = new Socket(""localhost"", 1982);
DataOutputStream opStr = new DataOutputStream(client.getOutputStream());

//pw = new PrintWriter(client.getOutputStream(), true);
//pw.println(""Hello, is there anybody out there?"");// Can be read by BufferedReader
opStr.writeUTF(""Hello, anyone there?"");
opStr.flush();// BufferedReader can't read it
</code></pre>

<p><strong>2. Server:</strong></p>

<pre><code> openServer();// port 1982
while(true) {
Socket clientSocket = null;

// listen to connection.
clientSocket = echoServer.accept();

DataInputStream inStr = new DataInputStream(
clientSocket.getInputStream());

//System.out.println(""M1: Got msg "" + inStr.readUTF());// It showed the content

BufferedReader bfReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

System.out.println(""got Messages: "");
String strLine = """";
// Don't show anything
while ((strLine = bfReader.readLine()) != null) {
System.out.println(strLine);
}
}
</code></pre>","<p>You want to read the files as either text e.g. BufferedReader OR binary e.g. DataInputStream. So you can't use both.</p>

<h2>Server.java</h2>

<pre><code>public class Server 
{
public static void main(String[] args) 
{
DataInputStream inStr = null;
String str;
openServer();// port 1982
while(true) 
{
Socket clientSocket = null;
// listen to connection.
clientSocket = echoServer.accept();
try
{
inStr = new DataInputStream(clientSocket.getInputStream());
str = inStr.readUTF();
System.out.print((String) str);
System.out.flush(); 
} 
catch (IOException io) 
{
System.err.println(""I/O error occurred: "" + io);
} 
catch (Throwable anything) 
{
System.err.println(""Exception caught !: "" + anything);
}
finally 
{
if (inStr != null) 
{
try 
{
inStr.close();
} 
catch (IOException io) 
{
System.err.println(""I/O error occurred: "" + io);
}
}
}
}
}

}
</code></pre>",31672179,0,java|sockets
How to use BufferedReader to read content in DataInputStream,"<p>I wrote a simple socket tutorial about sending/receive messages between client and server. I used DataOutputStream to write the string in stream but server couldn't read it if I used <strong>BufferedReader</strong></p>

<p>If I use PrintWriter to write(client side), it works.</p>

<p>What's wrong here? Tks so much.</p>

<p><strong>1. Client:</strong> </p>

<pre class=""lang-java prettyprint-override""><code> client = new Socket(""localhost"", 1982);
DataOutputStream opStr = new DataOutputStream(client.getOutputStream());

//pw = new PrintWriter(client.getOutputStream(), true);
//pw.println(""Hello, is there anybody out there?"");// Can be read by BufferedReader
opStr.writeUTF(""Hello, anyone there?"");
opStr.flush();// BufferedReader can't read it
</code></pre>

<p><strong>2. Server:</strong></p>

<pre><code> openServer();// port 1982
while(true) {
Socket clientSocket = null;

// listen to connection.
clientSocket = echoServer.accept();

DataInputStream inStr = new DataInputStream(
clientSocket.getInputStream());

//System.out.println(""M1: Got msg "" + inStr.readUTF());// It showed the content

BufferedReader bfReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));

System.out.println(""got Messages: "");
String strLine = """";
// Don't show anything
while ((strLine = bfReader.readLine()) != null) {
System.out.println(strLine);
}
}
</code></pre>","<p>You can't. If you use <code>writeUTF()</code> at one end, you have to use <code>readUTF()</code> at the other end.</p>

<p>You just have to decide which API you're going to use, instead of trying to mix and match them.</p>",31672179,2,java|sockets
How to load a UTF-8 text file with InputStream,"<p>I want to load a .txt file from my assets folder into a text view by pressing a button. I did this so but my problem is that my text file is UTF-8 Encoded text and some strange characters are copied into my TextView instead my true words...
Here is my code and method I wrote but I don't know where I should put ""UTF-8"" as an argument..</p>

<pre><code>b1.setOnClickListener(new View.OnClickListener() { 
@Override
public void onClick(View arg0) { 
try {
InputStream iFile = getAssets().open(""mytext.txt"");
String strFile = inputStreamToString(iFile);
Intent intent=new Intent(MyActivity.this,SecondActivity.class);
intent.putExtra(""myExtra"", strFile);
final int result=1;
startActivityForResult(intent, result);
} catch (IOException e) { 
e.printStackTrace();
}

public String inputStreamToString(InputStream is) throws IOException {
StringBuffer sBuffer = new StringBuffer();
DataInputStream dataIO = new DataInputStream(is);
String strLine = null;
while ((strLine = dataIO.readLine()) != null) {
sBuffer.append(strLine + ""\n"");
}
dataIO.close();
is.close();
return sBuffer.toString();
}
</code></pre>

<p>Thanks for your help ;-)</p>","<p>Following code reads your file into byte array buffer and converts it to string </p>

<pre><code>public String inputStreamToString(InputStream is) throws IOException {
byte[] buffer = new byte[is.available()];
int bytesRead = is.read(buffer);
return new String(buffer, 0, bytesRead, ""UTF-8"");
}
</code></pre>",28393963,1,java|android|utf-8|io|inputstream
How to convert Generic Arraylist into Array in Java?,"<p>I need to change this program to use a array instead of an arraylist. Apparently I need to create an array of objects and cast it to E[] but I don't understand how to do this. Any help is appreciated.</p>

<pre><code>public class GenericStack&lt;E&gt; {
private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;E&gt;();

public int getSize() {
return list.size();
}

public E peek() {
return list.get(getSize() - 1);
}

public E push(E o) {
list.add(o);
return o;
}

public E pop() {
E o = list.get(getSize() - 1);
list.remove(getSize() - 1);
return o;
}

public boolean isEmpty() {
return list.isEmpty();
}
}
</code></pre>","<p>You can use following command to create the array.</p>

<pre><code>private E[] arr;
private int index;

public void initialize() {
arr = (E[]) new Object[100];
index = 0;
}

public E push(E o) {
try {
arr[index++] = o;
} catch (Exception e) {
System.out.println(""Array not enough.."");
}
return o;
}
</code></pre>

<p>Using this you can implement other methods as well. <code>index</code> can be used to calculate the size of the stack. </p>

<p>In above example, an error was printed when the array bounds were exceeded. Instead you can copy array into another variable when <code>index == arr.length - 1</code>. You can use following function to copy the array..</p>

<pre><code>private void copyArray() {
E[] tem = (E[]) new Object[arr.length + 100];
System.arraycopy(arr, 0, tem, 0, arr.length);
arr = tem;
}
</code></pre>",33950239,0,java|arrays|generics
How to convert Generic Arraylist into Array in Java?,"<p>I need to change this program to use a array instead of an arraylist. Apparently I need to create an array of objects and cast it to E[] but I don't understand how to do this. Any help is appreciated.</p>

<pre><code>public class GenericStack&lt;E&gt; {
private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;E&gt;();

public int getSize() {
return list.size();
}

public E peek() {
return list.get(getSize() - 1);
}

public E push(E o) {
list.add(o);
return o;
}

public E pop() {
E o = list.get(getSize() - 1);
list.remove(getSize() - 1);
return o;
}

public boolean isEmpty() {
return list.isEmpty();
}
}
</code></pre>","<p>Actually what you want to do is a Stack Implementation using an Array.</p>

<h3>Generic Stack Implementation With Array</h3>

<pre><code>public class GenericStack&lt;E&gt; {
private int index;
private E[] array;

public GenericStack(int size) {
array = (E[]) new Object[size];
index = 0;
}

public int getSize() {
return index;
}

public int getCapacity() {
return array.length;
}

public E peek() {
return array[index-1];
}

// push MUST be void, it only pushes the value into the stack
public void push(E o) {
array[index++] = o;
}


public E pop() {
E o = array[index-1];
index--;

return o;
}

public boolean isEmpty() {
return index == 0 ? true : false; 
}
}
</code></pre>

<h3>Test Code</h3>

<pre><code>public class TestGenericStack {

public static void main(String[] args) {
GenericStack&lt;Integer&gt; genStack = new GenericStack&lt;Integer&gt;(10);

// test size
System.out.println(""Size of the Stack : "" + genStack.getSize());

// test isEmpty()
System.out.println(""Stack isEmpty : "" + genStack.isEmpty());


System.out.println(""*** Stack push operations ***"");

// test push
genStack.push(new Integer(10));
genStack.push(new Integer(20));
genStack.push(new Integer(30));
genStack.push(new Integer(15));
genStack.push(new Integer(99));



// test isEmpty()
System.out.println(""Stack isEmpty : "" + genStack.isEmpty());

// test peek
System.out.println(""Top of the Stack : "" + genStack.peek());

// test size
System.out.println(""Size of the Stack : "" + genStack.getSize());

// test pop
System.out.println(""Pop from the Stack : "" + genStack.pop());

// test peek
System.out.println(""Top of the Stack : "" + genStack.peek());

// test size
System.out.println(""Size of the Stack : "" + genStack.getSize());
}

}
</code></pre>

<h3>Console Output</h3>

<pre><code>Size of the Stack : 0
Stack isEmpty : true
*** Stack push operations ***
Stack isEmpty : false
Top of the Stack : 99
Size of the Stack : 5
Pop from the Stack : 99
Top of the Stack : 15
Size of the Stack : 4
</code></pre>",33950239,0,java|arrays|generics
How to convert Generic Arraylist into Array in Java?,"<p>I need to change this program to use a array instead of an arraylist. Apparently I need to create an array of objects and cast it to E[] but I don't understand how to do this. Any help is appreciated.</p>

<pre><code>public class GenericStack&lt;E&gt; {
private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;E&gt;();

public int getSize() {
return list.size();
}

public E peek() {
return list.get(getSize() - 1);
}

public E push(E o) {
list.add(o);
return o;
}

public E pop() {
E o = list.get(getSize() - 1);
list.remove(getSize() - 1);
return o;
}

public boolean isEmpty() {
return list.isEmpty();
}
}
</code></pre>","<p>Instead of:</p>

<pre><code>private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;E&gt;();
</code></pre>

<p>use:</p>

<pre><code>private Object[] array = new Object[];
</code></pre>

<p>And when you have to return a certain value, cast it to E. For example:</p>

<pre><code>public E get(int i) {
return (E) array[i];
}
</code></pre>

<p>This is necessary because Java does not allow you to create arrays of generic type.</p>",33950239,1,java|arrays|generics
How to convert Generic Arraylist into Array in Java?,"<p>I need to change this program to use a array instead of an arraylist. Apparently I need to create an array of objects and cast it to E[] but I don't understand how to do this. Any help is appreciated.</p>

<pre><code>public class GenericStack&lt;E&gt; {
private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;E&gt;();

public int getSize() {
return list.size();
}

public E peek() {
return list.get(getSize() - 1);
}

public E push(E o) {
list.add(o);
return o;
}

public E pop() {
E o = list.get(getSize() - 1);
list.remove(getSize() - 1);
return o;
}

public boolean isEmpty() {
return list.isEmpty();
}
}
</code></pre>","<p>You can initialize a generic array like this:</p>

<pre><code>E[] stack = (E[])new Object[size];
</code></pre>

<p>I find a generic stack sample in another question: <a href=""https://stackoverflow.com/questions/5293140/generic-stack-array"">Generic Stack Array</a></p>",33950239,0,java|arrays|generics
How to convert Generic Arraylist into Array in Java?,"<p>I need to change this program to use a array instead of an arraylist. Apparently I need to create an array of objects and cast it to E[] but I don't understand how to do this. Any help is appreciated.</p>

<pre><code>public class GenericStack&lt;E&gt; {
private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;E&gt;();

public int getSize() {
return list.size();
}

public E peek() {
return list.get(getSize() - 1);
}

public E push(E o) {
list.add(o);
return o;
}

public E pop() {
E o = list.get(getSize() - 1);
list.remove(getSize() - 1);
return o;
}

public boolean isEmpty() {
return list.isEmpty();
}
}
</code></pre>","<p>The generics are removed in compilation, thus the <code>Helper.toArray</code> will be compiled into returning an <code>Object[]</code>.</p>

<p>For this particular case, I suggest you use List.toArray(E[]).</p>

<pre><code>List&lt;E&gt; list = new ArrayList&lt;E&gt;();
list.add(...);
list.add(...);

T[]array = list.toArray(new E[list.size()]);
</code></pre>",33950239,-2,java|arrays|generics
How to convert Generic Arraylist into Array in Java?,"<p>I need to change this program to use a array instead of an arraylist. Apparently I need to create an array of objects and cast it to E[] but I don't understand how to do this. Any help is appreciated.</p>

<pre><code>public class GenericStack&lt;E&gt; {
private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;E&gt;();

public int getSize() {
return list.size();
}

public E peek() {
return list.get(getSize() - 1);
}

public E push(E o) {
list.add(o);
return o;
}

public E pop() {
E o = list.get(getSize() - 1);
list.remove(getSize() - 1);
return o;
}

public boolean isEmpty() {
return list.isEmpty();
}
}
</code></pre>","<p>Array's can't use generic types because it needs to allocate the memory for the type. Therefore, it needs to know which type it is beforehand. You can use the newInstance() method to convert your stack implemented with ArrayList to an Array. The code will look like this.</p>

<pre class=""lang-java prettyprint-override""><code>public E[] toArray() {

if (size == 0)
return null;

E temp = list.get(0);
E[] stackArray = (E[]) Array.newInstance(temp.getClass(), size);
for (int i = 0; i &lt; list.size(); i++) {
stackArray[i] = list.get(i);
}
return (E[]) stackArray;
}
</code></pre>",33950239,0,java|arrays|generics
How to use MySql Database queries in Spring Boot?,"<p>I am creating an API by using spring boot. In this project, I used spring web, JPA, jstl and MySql as dependencies of the API. In this project, I have created a Controller, Model and Repository. Basically, this API does CRUD operations. When I use GET request, I want to get only 3 columns. But, the case is I used JPA in this and I don't know how to use custom queries like </p>

<blockquote>
<p>""SELECT devname,hrs,ot FROM imaginaryTable""</p>
</blockquote>

<p>. </p>

<p>How can I do this ??</p>

<p>My Controller class.</p>

<pre><code>@RestController
@RequestMapping(""/api"")
public class ImController {

@Autowired
private ImRepository TaskRepository;

@GetMapping(""/projects"")
public List&lt;ImModel&gt; findAll() {
return (List&lt;ImModel&gt;) TaskRepository.findAll();
}

@GetMapping(""/developers/{id}"")
public ImModel findByName(@PathVariable final int id){
return TaskRepository.findById(id);
}

}
</code></pre>

<p>My Repository interface.</p>

<pre><code>package com.kisalka.pacrestapi.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.kisalka.pacrestapi.model.ImModel;

public interface ImRepository extends JpaRepository&lt;ImModel, Integer&gt; {

ImModel findById(int id);

}
</code></pre>","<p>You could use <code>@Query(""Your query"")</code> annotation inside the repository to query the database. 
For Example</p>

<pre><code>@Query(value=""SELECT devname,hrs,ot FROM imaginaryTable"",nativeQuery=true)
private List&lt;Object&gt; getValues();
</code></pre>

<p>Hope it solves your issue.</p>",50096376,1,java|mysql|spring|spring-boot|spring-data-jpa
How to use MySql Database queries in Spring Boot?,"<p>I am creating an API by using spring boot. In this project, I used spring web, JPA, jstl and MySql as dependencies of the API. In this project, I have created a Controller, Model and Repository. Basically, this API does CRUD operations. When I use GET request, I want to get only 3 columns. But, the case is I used JPA in this and I don't know how to use custom queries like </p>

<blockquote>
<p>""SELECT devname,hrs,ot FROM imaginaryTable""</p>
</blockquote>

<p>. </p>

<p>How can I do this ??</p>

<p>My Controller class.</p>

<pre><code>@RestController
@RequestMapping(""/api"")
public class ImController {

@Autowired
private ImRepository TaskRepository;

@GetMapping(""/projects"")
public List&lt;ImModel&gt; findAll() {
return (List&lt;ImModel&gt;) TaskRepository.findAll();
}

@GetMapping(""/developers/{id}"")
public ImModel findByName(@PathVariable final int id){
return TaskRepository.findById(id);
}

}
</code></pre>

<p>My Repository interface.</p>

<pre><code>package com.kisalka.pacrestapi.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.kisalka.pacrestapi.model.ImModel;

public interface ImRepository extends JpaRepository&lt;ImModel, Integer&gt; {

ImModel findById(int id);

}
</code></pre>","<p>You could customise the JSON representation of the entity in the Controller by using Spring's support for Jackson's JSONView.</p>

<p><a href=""https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring#json-views"" rel=""nofollow noreferrer"">https://spring.io/blog/2014/12/02/latest-jackson-integration-improvements-in-spring#json-views</a></p>

<pre><code> @JsonView(View.Summary.class)
@GetMapping(""/developers/{id}"")
public ImModel findByName(@PathVariable final int id){
return TaskRepository.findById(id);
}
</code></pre>

<p>Alternatively, you could handle at the repository level by using Spring Data's projection functionality:</p>

<p><a href=""https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#projections"" rel=""nofollow noreferrer"">https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#projections</a></p>

<pre><code> @GetMapping(""/developers/{id}"")
public ImModelSummaryProjection findByName(@PathVariable final int id){
return TaskRepository.someMethodReturningSummaryProjection(id);
}
</code></pre>",50096376,0,java|mysql|spring|spring-boot|spring-data-jpa
How to use MySql Database queries in Spring Boot?,"<p>I am creating an API by using spring boot. In this project, I used spring web, JPA, jstl and MySql as dependencies of the API. In this project, I have created a Controller, Model and Repository. Basically, this API does CRUD operations. When I use GET request, I want to get only 3 columns. But, the case is I used JPA in this and I don't know how to use custom queries like </p>

<blockquote>
<p>""SELECT devname,hrs,ot FROM imaginaryTable""</p>
</blockquote>

<p>. </p>

<p>How can I do this ??</p>

<p>My Controller class.</p>

<pre><code>@RestController
@RequestMapping(""/api"")
public class ImController {

@Autowired
private ImRepository TaskRepository;

@GetMapping(""/projects"")
public List&lt;ImModel&gt; findAll() {
return (List&lt;ImModel&gt;) TaskRepository.findAll();
}

@GetMapping(""/developers/{id}"")
public ImModel findByName(@PathVariable final int id){
return TaskRepository.findById(id);
}

}
</code></pre>

<p>My Repository interface.</p>

<pre><code>package com.kisalka.pacrestapi.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.kisalka.pacrestapi.model.ImModel;

public interface ImRepository extends JpaRepository&lt;ImModel, Integer&gt; {

ImModel findById(int id);

}
</code></pre>","<p>As described in Spring Docs: 
<strong><a href=""https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#projections"" rel=""nofollow noreferrer"">Interface-based projections</a></strong>
The easiest way to limit the result of the queries to expose the name attributes only is by declaring an interface that will expose accessor methods for the properties to be read.</p>

<p>You can create <code>interface</code> to limit results</p>

<pre><code>interface LimitImaginaryTable {
String getDevname();
String getHrs();
String getOt();
}
</code></pre>

<p>and then in your <code>repository</code> you can use that interface to get limited results</p>

<pre><code>public interface ImRepository extends JpaRepository&lt;ImModel, Integer&gt; {

ImModel findById(int id);
LimitImaginaryTable findById(int id);
List&lt;LimitImaginaryTable&gt; findByDevname(String name);

}
</code></pre>

<p>Now you can simply get the desired resultset in <code>Controller</code></p>

<pre><code>List&lt;LimitImaginaryTable&gt; myList = taskRepository.findByDevname(""JavaDev"");
</code></pre>",50096376,0,java|mysql|spring|spring-boot|spring-data-jpa
How to use MySql Database queries in Spring Boot?,"<p>I am creating an API by using spring boot. In this project, I used spring web, JPA, jstl and MySql as dependencies of the API. In this project, I have created a Controller, Model and Repository. Basically, this API does CRUD operations. When I use GET request, I want to get only 3 columns. But, the case is I used JPA in this and I don't know how to use custom queries like </p>

<blockquote>
<p>""SELECT devname,hrs,ot FROM imaginaryTable""</p>
</blockquote>

<p>. </p>

<p>How can I do this ??</p>

<p>My Controller class.</p>

<pre><code>@RestController
@RequestMapping(""/api"")
public class ImController {

@Autowired
private ImRepository TaskRepository;

@GetMapping(""/projects"")
public List&lt;ImModel&gt; findAll() {
return (List&lt;ImModel&gt;) TaskRepository.findAll();
}

@GetMapping(""/developers/{id}"")
public ImModel findByName(@PathVariable final int id){
return TaskRepository.findById(id);
}

}
</code></pre>

<p>My Repository interface.</p>

<pre><code>package com.kisalka.pacrestapi.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import com.kisalka.pacrestapi.model.ImModel;

public interface ImRepository extends JpaRepository&lt;ImModel, Integer&gt; {

ImModel findById(int id);

}
</code></pre>","<p>You can create an object by using the columns as parameters for a constructor.</p>

<p>I'll give you an example of my own with a custom DTO I made:</p>

<pre><code>@Query(""SELECT new org.twinnation.site.dto.TitleAndDescriptionAndId(a.title, a.description, a.id) ""
+ ""FROM Article a"")
List&lt;TitleAndDescriptionAndId&gt; getAllArticlesWithoutContent();
</code></pre>

<p>Where the DTO <code>TitleAndDescriptionAndId</code> is the following:</p>

<pre><code>public class TitleAndDescriptionAndId {

private String title;
private String description;
private Long id;


public TitleAndDescriptionAndId(String title, String description, Long id) {
this.title = title;
this.description = description;
this.id = id;
}

// ...

}
</code></pre>",50096376,1,java|mysql|spring|spring-boot|spring-data-jpa